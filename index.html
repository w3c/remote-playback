<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <title>
      Remote Playback API
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" async
    class="remove">
    </script>
    <script class="remove">
    var respecConfig = {
        specStatus: 'ED',
        edDraftURI: 'https://w3c.github.io/remote-playback/',
        shortName:  'remote-playback',
        editors: [
          {
            w3cid: 45389,
            name: 'Mounir Lamouri',
            company: 'Google',
          },
          {
            w3cid: 68811,
            name: 'Anton Vayvod',
            company: 'Google',
            note: 'Former Editor',
          },
        ],
        sotdAfterWGinfo: true,
        license: "w3c-software-doc",
        // previousMaturity: 'WD',
        // previousPublishDate: '2015-11-02',
        otherLinks: [
          {
            key: 'Version history',
            data: [
              {
                value: 'GitHub w3c/remote-playback/commits',
                href: 'https://github.com/w3c/remote-playback/commits/'
              }
            ]
          },
          {
            key: 'Test suite',
            data: [
              {
                value: 'GitHub web-platform-tests/remote-playback',
                href: 'https://github.com/w3c/web-platform-tests/tree/master/remote-playback'
              },
              {
                value: 'w3c-test.org/remote-playback/',
                href: 'https://w3c-test.org/remote-playback/'
              }
            ]
          },
          {
            key: 'Participate',
            data: [
              {
                value: 'GitHub w3c/remote-playback',
                href: 'https://github.com/w3c/remote-playback/'
              },
              {
                value: 'File an issue',
                href: 'https://github.com/w3c/remote-playback/issues/new'
              },
              {
                value: 'Open issues',
                href: 'https://github.com/w3c/remote-playback/issues/'
              },
              {
                value: 'Mailing-list (public-secondscreen@w3.org)',
                href: 'https://lists.w3.org/Archives/Public/public-secondscreen/'
              }
            ]
          }
        ],
        wg: 'Second Screen Working Group',
        wgURI: 'https://www.w3.org/2014/secondscreen/',
        wgPublicList: 'public-secondscreen',
        wgPatentURI: 'https://www.w3.org/2004/01/pp-impl/74168/status',
        implementationReportURI: 'https://www.w3.org/wiki/Second_Screen/Implementation_Status#Remote_Playback_API'
      };
    </script>
    <style>
    /* Note formatting taken from Presentation API spec for consistency in the
       Second Screen WG */
    .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    .note em, .warning em, .note i, .warning i { font-style: normal; }
    p.note, div.note { padding: 0.5em 2em; }
    span.note { padding: 0 2em; }
    .note p:first-child { margin-top: 0; }
    .note p:last-child { margin-bottom: 0; }
    p.note:before { content: 'NOTE: '; }
    .non-normative { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    p.non-normative:before { content: 'Non-normative: '; font-weight: bolder;}
    p.non-normative, div.non-normative { padding: 0.5em 2em; }
    .algorithm li {
        margin-bottom: 0.5em;
    }
    .interface dd, .parameters dt {
        margin-bottom: 0.5em;
    }
    code { color: orangered; }
    table { border-collapse: collapse; border-style: hidden hidden none hidden; }
    table thead, table tbody { border-bottom: solid; }
    table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    dfn { font-weight: bolder; font-style: normal; }
    .copyright { font-size: small; }
    .issue[id^='issue-'] > *:not([role='heading']) { display: none; }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This specification defines an API extending the
        <code><a>HTMLMediaElement</a></code> that enables controlling remote
        playback of media from a web page.
      </p>
    </section>
    <section id="sotd">
      <p>
        This document builds on the group's experience on presenting web
        content on external presentation-type displays, and re-uses patterns
        and design considerations from the Presentation API specification
        whenever appropriate [[PRESENTATION-API]].
      </p>
      <p>
        Although this document is still a <strong>work in progress</strong> and
        is subject to change, the Working Group believes that the API surface is
        stable. Most of the remaining issues listed on the <a href=
        "https://github.com/w3c/remote-playback/issues/">issue tracker</a> are
        considered minor at this stage except for
        Issue <a href="https://github.com/w3c/remote-playback/issues/41">#41</a>.
      </p>
      <p>
        Issue <a href="https://github.com/w3c/remote-playback/issues/41">#41</a>
        discusses the set of media playback features that remote playback
        devices are expected to support. The group will seek further developer
        feedback and implementation experience to identify any interoperability
        issues around these features when used during remote playback, and will
        further clarify the specification based on feedback received.
      </p>
      <p>
        For other issues or concerns, it is possible to <a href=
        'https://github.com/w3c/remote-playback/issues/new'>file a bug</a> or
        send an email to the <a href=
        'https://lists.w3.org/Archives/Public/public-secondscreen/'>mailing
        list</a>. For small editorial changes like typos, sending a pull request
        is appreciated.
      </p>
      <p>
        The Working Group invites everyone to review this document, and will
        work with relevant groups at W3C to conduct horizontal reviews on
        accessibility, internationalization, privacy, security and technical
        architecture principles.
      </p>
      <p>
        No feature has been identified as being <strong>at risk</strong>.
      </p>
      <p>
        The Second Screen Working Group will develop a test suite for the
        Remote Playback API during the Candidate Recommendation period and
        prepare an implementation report. For this specification to advance to
        Proposed Recommendation, two independent, interoperable implementations
        of each feature must be demonstrated, as detailed in the <a href=
        "#candidate-recommendation-exit-criteria">Candidate Recommendation exit
        criteria</a> section.
      </p>
    </section>
    <section id='conformance'>
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to expose the APIs defined in this
        specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]].
      </p>
    </section>
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        This specification aims to make <a>remote playback devices</a> such as
        connected TVs, projectors or audio-only speakers, available to the Web
        and takes into account playback devices that are attached using wired
        (HDMI, DVI, or similar) and wireless technologies (Miracast,
        Chromecast, DLNA, AirPlay, or similar).
      </p>
      <p>
        Devices with limited screen size or quiet speakers lack the ability to
        playback media content to a larger audience, for example, a group of
        colleagues in a conference room, or friends and family at home. Playing
        media content on an external larger and/or louder <a>remote playback
        device</a> helps to improve the perceived quality and impact of the
        played media.
      </p>
      <p>
        At its core, this specification enables a page that acts as the
        <a>browsing context</a> to initiate and control remote playback of a
        particular media element on a selected <a>remote playback device</a>.
        How the remoting is initiated and controlled is left to the UA in order
        to allow the use of <a>remote playback devices</a> that can be attached
        in a wide variety of ways. For example, when a <a>remote playback
        device</a> is attached using HDMI or Miracast, the same UA that acts as
        the <a>browsing context</a> renders the remote media. Instead of
        playing the media on the same device, however, it can use whatever
        means the operating system provides for using the external <a>remote
        playback device</a>. In such a case, both the <a>browsing context</a>
        and the media player run on the same UA and the operating system is
        used to route the player output to the <a>remote playback device</a>.
        This is commonly referred to as the <dfn><b id="media-mirroring">media
        mirroring</b></dfn> case. This specification imposes no requirements on
        the <a>remote playback devices</a> connected in such a manner.
      </p>
      <p>
        If the <a>remote playback device</a> is able to play the media and
        communicate with the <a>browsing context</a> but is unable to fetch the
        media, the <a>browsing context</a> needs to fetch the media data and
        pass it on to the <a>remote playback device</a> for rendering. This is
        commonly referred to as <dfn><b id="media-remoting">media
        remoting</b></dfn> case.
      </p>
      <p>
        If the <a>remote playback device</a> is able to fetch and play the
        media and communicate with the <a>browsing context</a>, the <a>browsing
        context</a> does not need to fetch or render the remoted media. In this
        case, the UA acts as a proxy that requests the <a>remote playback
        device</a> to play the media itself by passing the necessary data like
        the media source. This is commonly referred to as the <dfn><b id=
        "media-flinging">media flinging</b></dfn> case. This way of attaching
        to displays could be enhanced in the future by defining a standard
        protocol for delivering these types of messages that remote playback
        devices could choose to implement.
      </p>
      <p>
        The API defined here is intended to be used with UAs that attach to
        <a>remote playback device</a> devices through any of the above means.
      </p>
    </section>
    <section class='informative'>
      <h2>
        Use cases and requirements
      </h2>
      <p>
        The use cases and requirements of this specification are captured in a
        separate document available <a href=
        'https://github.com/w3c/remote-playback/blob/gh-pages/use-cases.md'>here</a>.
      </p>
    </section>
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        The following concepts and interfaces are defined in [[!HTML]]:
      </p>
      <ul>
        <li>
          <dfn><a href=
          'https://html.spec.whatwg.org/multipage/embedded-content.html#htmlmediaelement'>
          HTMLMediaElement</a></dfn>, <dfn><a href=
          'https://html.spec.whatwg.org/multipage/embedded-content.html#media-element'>
          media element</a></dfn>, <dfn data-lt=
          "resource selection algorithm"><a href=
          "https://html.spec.whatwg.org/multipage/embedded-content.html#concept-media-load-algorithm">
          selecting media resource</a></dfn>, <dfn data-lt=
          "currentSrc"><a href="https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-currentsrc">
          current source</a></dfn>,
	  <dfn><a href="https://html.spec.whatwg.org/multipage/media.html#dom-media-fastseek">fastSeek</a></dfn>,
	  <dfn><a href="https://html.spec.whatwg.org/multipage/media.html#dom-media-seeking">seeking</a></dfn>,
          <dfn data-lt="media resources"><a href=
          "https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource">
          media resource</a></dfn>, and <dfn data-lt="exposing a user interface to the user"><a href=
          "https://html.spec.whatwg.org/multipage/embedded-content.html#expose-a-user-interface-to-the-user">
          expose a user interface to the user</a></dfn>
        </li>
        <li>
          <dfn><a href=
          'https://html.spec.whatwg.org/multipage/browsers.html#browsing-context'>
          browsing context</a></dfn>, <dfn><a href=
          "https://www.w3.org/TR/html5/browsers.html#nested-browsing-contexts">nested
          browsing context</a></dfn>and <dfn><a href=
          'https://html.spec.whatwg.org/multipage/browsers.html#allowed-to-show-a-popup'>
          allowed to show a popup</a></dfn>
        </li>
        <li>
          <dfn><a href=
          'https://html.spec.whatwg.org/multipage/webappapis.html#event-handlers'>
          event handler</a></dfn>, <dfn><a href=
          'https://html.spec.whatwg.org/multipage/webappapis.html#event-handler-event-type'>
          event handler event type</a></dfn>, <dfn><a href=
          'https://html.spec.whatwg.org/multipage/webappapis.html#fire-a-simple-event'>
          fire a simple event</a></dfn> and <dfn><a href=
          'https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-task'>
          queue a task</a></dfn>
        </li>
        <li>
          <dfn data-lt='fire|fires'><a href=
          'https://html.spec.whatwg.org/multipage/infrastructure.html#concept-event-fire'>
          firing an event</a></dfn> and <dfn><a href=
          'https://html.spec.whatwg.org/multipage/infrastructure.html#in-parallel'>
          in parallel</a></dfn>,
        </li>
        <li>
          <dfn><a href=
          'https://html.spec.whatwg.org/multipage/scripting.html#cereactions'><code>
          [CEReactions]</code></a></dfn>
        </li>
      </ul>
      <p>
        The term <dfn><a href="https://url.spec.whatwg.org/#url">URL</a></dfn>
        is defined in the WHATWG URL standard [[!URL]].
      </p>
      <p>
        The term <dfn>throw</dfn> in this specification is used as defined in
        [[!WEBIDL]].
      </p>
      <p>
        The term <dfn><a href=
        "https://www.w3.org/TR/mixed-content/#potentially-secure-origin">potentially
        secure</a></dfn> is defined in [[!MIXED-CONTENT]].
      </p>
      <p>
        The following exception names are defined by [[!WEBIDL]] and used by
        this specification:
      </p>
      <ul>
        <li>
          <dfn><code>InvalidAccessError</code></dfn>
        </li>
        <li>
          <dfn><code>InvalidStateError</code></dfn>
        </li>
        <li>
          <dfn><code>NotAllowedError</code></dfn>
        </li>
        <li>
          <dfn><code>NotFoundError</code></dfn>
        </li>
        <li>
          <dfn><code>NotSupportedError</code></dfn>
        </li>
        <li>
          <dfn><code>OperationError</code></dfn>
        </li>
      </ul>
    </section>
    <section>
      <h2>
        Examples
      </h2>
      <p>
        This section shows code examples that highlight the usage of the main
        features of the Remote Playback API. In these examples,
        <code>player.html</code> implements the player page controlling the
        remote playback and <code>media.ext</code> is the media file to be
        played remotely. Both the page and the media are served from the domain
        <code>https://example.org</code>. Please refer to the comments in the
        code examples for further details.
      </p>
      <section>
        <h3>
          Monitor availability of remote playback devices example
        </h3>
        <pre class="example">
&lt;!-- player.html --&gt;
&lt;!-- The video element with custom controls that supports remote playback. --&gt;
&lt;video id="videoElement" src="https://example.org/media.ext" /&gt;
&lt;button id="deviceBtn" style="display: none;"&gt;Pick device&lt;/button&gt;
&lt;script&gt;
  // The "Pick device" button is visible if at least one remote playback device is available.
  var deviceBtn = document.getElementById("deviceBtn");
  var videoElem = document.getElementById("videoElement");

  function availabilityCallback(available) {
    // Show or hide the device picker button depending on device availability.
    deviceBtn.style.display = available ? "inline" : "none";
  }

  videoElem.remote.watchAvailability(availabilityCallback).catch(function() {
    // Availability monitoring is not supported by the platform, so discovery of
    // remote playback devices will happen only after remote.prompt() is called.
    // Pretend the devices are available for simplicity; or, one could implement
    // a third state for the button.
    deviceBtn.style.display = "inline";
  });
&lt;/script&gt;
        </pre>
      </section>
      <section>
        <h3>
          Starting remote playback of a video example
        </h3>
        <pre class="example">
&lt;!-- player.html --&gt;
&lt;script&gt;
  devicesBtn.onclick = function() {
    // Request the user to select a remote playback device.
    videoElem.remote.prompt()
      // Update the UI and monitor the connected state.
      .then(updateRemotePlaybackState);
      // Otherwise, the user cancelled the selection UI or no screens were found.
  };
&lt;script&gt;
        </pre>
      </section>
      <section>
        <h3>
          Monitoring remote playback state changes
        </h3>
        <pre class="example">
&lt;!-- player.html --&gt;
&lt;script&gt;
  // The remote playback may be initiated by the user agent,
  // so check the initial state to sync the UI with it.
  if (videoElem.remote.state == "disconnected")
    switchToLocalUI();
  else
    switchToRemoteUI();

  videoElem.remote.onconnecting = switchToRemoteUI;
  videoElem.remote.onconnect = swithToRemoteUI;
  videoElem.remote.ondisconnect = switchToLocalUI;

  // Handles both 'connecting' and 'connected' state. Calling more than once
  // is a no-op.
  function switchToRemoteUI() {
    // Indicate that the state is 'connecting' or 'connected' to the user.
    // For example, hide the video element as only controls are needed.
    videoElem.style.display = "none";

    // Stop monitoring the availability of remote playback devices.
    videoElem.remote.cancelWatchAvailability();
  };

  function switchToLocalUI() {
    // Show the video element.
    videoElem.style.display = "inline";
    // Start watching the device availability again.
    videoElem.remote.watchAvailability(availabilityCallback);
  };
&lt;script&gt;
        </pre>
      </section>
    </section>
    <section>
      <h2>
        API
      </h2>
      <section>
        <h3>
          Common idioms
        </h3>
        <p>
          A <dfn>local playback device</dfn> is the device the <a>browsing
          context</a> is running on along with the default video/audio outputs
          the device has.
        </p>
        <div class="note">
          A <a>local playback device</a> might have extra outputs, like an
          external display or speakers/headphones. As long as the switch of
          what output to use happens outside of the <a>user agent</a> on the
          system level, the playback is considered to happen on a <a>local
          playback device</a> for the purpose of this spec.
        </div>
        <p></p>
        <p>
          A <dfn data-lt="remote playback devices">remote playback device</dfn>
          is any other device but the <a>local playback device</a> that the
          <a>browsing context</a> can use to play media on.
        </p>
        <p>
          A <dfn>media element state</dfn> is the set of all single <a>media
          element</a> properties observable by the page and/or the user via the
          <a>user agent</a> implementation. The new properties introduced by
          this spec are not considered part of the <a>media element state</a>
          for convenience.
        </p>
        <div class="example">
          For example, the <code>paused</code> attribute or the pause/resume
          button reflecting that state on the default controls of the media
          element would be a part of <a>media element state</a>.
        </div>
        <p></p>
        <p>
          A <dfn>local playback state</dfn> is the user agent implementation of
          <a>media element state</a> for the particular <a>media element</a>
          for playback on the <a>local playback device</a>.
        </p>
        <p>
          A <dfn>remote playback state</dfn> is the user agent implementation
          of <a>media element state</a> for the particular <a>media element</a>
          for playback on the certain <a>remote playback device</a>.
        </p>
        <p class="note">
          For a good user experience it is important that the <a>media element
          state</a> doesn't change unexpectedly when the
          <code><a data-link-for="RemotePlayback">state</a></code> changes. It
          is also important that <a>remote playback state</a> is in sync with
          the <a>media element state</a> so when the media is paused on the
          <a>remote playback device</a> it looks paused to both the user and
          the page.
        </p>
      </section>
      <section>
        <h3>
          <code><a>RemotePlayback</a></code> interface
        </h3>
        <pre class='idl'>
          interface RemotePlayback : EventTarget {
            Promise&lt;long&gt; watchAvailability(RemotePlaybackAvailabilityCallback callback);
            Promise&lt;void&gt; cancelWatchAvailability(optional long id);

            readonly attribute RemotePlaybackState state;

            attribute EventHandler onconnecting;
            attribute EventHandler onconnect;
            attribute EventHandler ondisconnect;

            Promise&lt;void&gt; prompt();
          };

          enum RemotePlaybackState {
            "connecting",
            "connected",
            "disconnected"
          };

          callback RemotePlaybackAvailabilityCallback = void(boolean available);
        </pre>
        <p>
          A <dfn>RemotePlayback</dfn> object is an interface allowing the page
          to detect availability of, connect to and control playback on
          <a>remote playback devices</a>.
        </p>
        <p>
          A <dfn>RemotePlaybackState</dfn> enumeration represents the state of
          connection to some <a>remote playback device</a>.
        </p>
        <p>
          A <dfn>RemotePlaybackAvailabilityCallback</dfn> represents the
          <a>remote playback device availability</a> information.
        </p>
        <section>
          <h4>
            Observing remote playback device availability
          </h4>
          <p>
            A <a><code>RemotePlaybackAvailabilityCallback</code></a> is the way
            for the page to obtain the <dfn>remote playback device
            availability</dfn> for the corresponding <a>media element</a>. If
            the user agent can <a>monitor the list of available remote playback
            devices</a> in the background (without a pending request to
            <code><a data-link-for="RemotePlayback">prompt</a>()</code>), the
            <a><code>RemotePlaybackAvailabilityCallback</code></a> behavior
            defined below MUST be implemented by the user agent. Otherwise, the
            promise returned by <code><a data-link-for=
            "RemotePlayback">watchAvailability</a>()</code> MUST be rejected
            with <a>NotSupportedError</a>.
          </p>
          <section>
            <h5>
              The set of availability callbacks
            </h5>
            <p>
              The <a>user agent</a> MUST keep track of the <dfn>set of
              availability callbacks</dfn> registered with each <a>media
              element</a> through the <code><a data-link-for=
              "RemotePlayback">watchAvailability</a>()</code> method. The
              <a>set of availability callbacks</a> for each
              <a>RemotePlayback</a> object is represented as a set of tuples
              <em>(<var>callbackId</var>, <var>callback</var>)</em>, initially
              empty, where:
            </p>
            <ol>
              <li>
                <var>callbackId</var> is a positive integer unique among all ids
                returned by
                <code><a data-link-for="RemotePlayback">watchAvailability</a>()</code>
                in a given <a>browsing context</a>;
              </li>
              <li>
                <var>callback</var> is a
                <a>RemotePlaybackAvailabilityCallback</a> object.
              </li>
            </ol>
            <p>
              Since there's one and only one <a>RemotePlayback</a> object per
              each <a>media element</a>, <a>set of availability callbacks</a>
              of a <a>media element</a> is the same set as the <a>set of
              availability callbacks</a> of the <a>RemotePlayback</a> object
              referred to by the element's <a data-link-for=
              "HTMLMediaElement">remote</a> property.
            </p>
            <p>
              The combined set of all <a data-lt=
              "set of availability callbacks">sets of availability
              callbacks</a> of all <a>RemotePlayback</a> objects known to the
              <a>browsing context</a> is referred to as <dfn>global set of
              availability callbacks</dfn>.
            </p>
          </section>
          <section>
            <h5>
              The list of available remote playback devices
            </h5>
            <p>
              The <a>user agent</a> MUST keep a <dfn>list of available remote
              playback devices</dfn>. This list contains <a>remote playback
              devices</a> and is populated based on an implementation specific
              discovery mechanism. It is set to the most recent result of the
              algorithm to <a>monitor the list of available remote playback
              devices</a> or an empty list if the algorithm hasn't been run
              yet.
            </p>
            <p>
              The <a>user agent</a> MAY not support running the algorithm to
              <a>monitor the list of available remote playback devices</a>
              continuously, for example, because of platform or power
              consumption restrictions. In this case the promise returned by
              <code><a data-link-for=
              "RemotePlayback">watchAvailability</a>()</code> MUST be rejected
              with <a>NotSupportedError</a>, the <a>global set of availability
              callbacks</a> will be empty and the algorithm to <a>monitor the
              list of available remote playback devices</a> will only run as
              part of the <a>initiate remote playback</a> algorithm.
            </p>
            <p>
              When the <a>global set of availability callbacks</a> is not
              empty, the <a>user agent</a> MUST <a>monitor the list of
              available remote playback devices</a> continuously, so that pages
              can keep track of the last value received via the registered
              callbacks to offer remote playback only when there are available
              devices.
            </p>
            <p class="note">
              User agents SHOULD NOT <a>monitor the list of available remote
              playback devices</a> when possible, to satisfy the <a href=
              "https://github.com/w3c/remote-playback/blob/gh-pages/use-cases.md#power-saving-friendly">
              power saving non-functional requirement</a>. For example, the
              <a>user agent</a> MAY not run the monitoring algorithm when the
              <a>global set of availability callbacks</a> is empty, when every
              page that has <a data-lt="media element">media elements</a> with
              non-empty <a>set of availability callbacks</a> is in the
              background.
            </p>
            <p>
              Some <a>remote playback devices</a> may only be able to play a
              subset of <a data-link-for="media resource">media resources</a>
              because of functional, security or hardware limitations. Examples
              are set-top boxes, smart TVs or networked speakers capable of
              rendering only certain formats of video and/or audio. We say that
              such a device is a <dfn>compatible remote playback device</dfn>
              for a <a>media resource</a> if the <a>user agent</a> can
              reasonably guarantee that the remote playback of the media
              specified by the resource will succeed on that device.
            </p>
            <p>
              The <a>media resources</a> of a <a>media element</a>, that were
              considered by the user agent to find a <a>compatible remote
              playback device</a>, are called the <dfn>availability sources
              set</dfn>.
            </p>
            <p>
              The <a>media resource</a> of a <a>media element</a>, that is used
              to <a>initiate remote playback</a> on the selected <a>remote
              playback device</a> is called <dfn>remote playback source</dfn>.
              Remote playback source MUST belong to <a>availability sources
              set</a>.
            </p>
            <p>
              The mechanism of picking the <a>availability sources set</a> and
              the <a>remote playback source</a> is implementation-specific. For
              example, the user agent MUST either use the <a data-link-for=
              "media element">currentSrc</a> of the <a>media element</a> for
              both availability monitoring and remote playback or use all the
              media resources associated with the media element as the
              <a>availability sources set</a> and pick one of the resources as
              the <a>remote playback source</a> after user selects the
              <a>remote playback device</a>.
            </p>
            <p>
              Remote playback is said to be <dfn>unavailable</dfn> for the
              <a>media element</a> if the <a>list of available remote playback
              devices</a> is empty or none of them is compatible with any
              source from <a>availability sources set</a> for the <a>media
              element</a>. The remote playback is said to be
              <dfn>available</dfn> otherwise. A <code>boolean</code> set to
              <code>false</code> if the remote playback is <a>unavailable</a>
              for the <a>media element</a> or <code>true</code> if it is
              <a>available</a> is called <dfn>availability</dfn> for the
              <a>media element</a>.
            </p>
            <p>
              If the user agent stops
              <a data-lt="monitor the list of available remote playback devices">
                monitoring the list of available remote playback devices</a>
              (for example by a user control or for power saving), it SHOULD
              invoke all callbacks in the <a>global set of availability
              callbacks</a> with <code>false</code> so that pages can update
              their user experience appropriately.  It SHOULD also set
              the <a>availability</a> value for all <a data-lt="media element">
              media elements</a> to <code>false</code> so that availability
              information can be propagated correctly if the user agent later
              resumes
              <a data-lt="monitor the list of available remote playback devices">
                monitoring the list of available remote playback devices</a>.
            </p>
          </section>
          <section>
            <h5>
              Getting the <a>remote playback devices</a> availability
              information
            </h5>
            <p>
              When the <code><dfn data-dfn-for=
              "RemotePlayback">watchAvailability</dfn>()</code> method is
              called, the user agent MUST run the following steps:
            </p>
            <dl>
              <dt>
                Input
              </dt>
              <dd>
                <var>callback</var>, the callback that will get fired with
                availability information.
              </dd>
              <dt>
                Output
              </dt>
              <dd>
                <var>promise</var>, a promise.
              </dd>
            </dl>
            <ol>
              <li>Let <var>promise</var> be a new promise.
              </li>
              <li>Return <var>promise</var>, and run the following steps below:
              </li>
              <li>If the <a data-link-for=
              "HTMLMediaElement">disableRemotePlayback</a> attribute is present
              for the <a>media element</a>, reject the <var>promise</var> with
              <a>InvalidStateError</a> and abort all the remaining steps.
              </li>
              <li>If the user agent is unable to <a>monitor the list of
              available remote playback devices</a> for the entire lifetime of
              the <a>browsing context</a> (for instance, because the user has
              disabled this feature), then run the following steps in parallel:
                <ol>
                  <li>Fulfill <var>promise</var>.
                  </li>
                  <li>
                    <a>Queue a task</a> to invoke the <var>callback</var> with
                    <code>false</code> as its argument.
                  </li>
                  <li>Abort all remaining steps.
                  </li>
                </ol>
              </li>
              <li>If the user agent is unable to continuously <a>monitor the
              list of available remote playback devices</a> but can do it for a
              short period of time when <a data-lt="initiate remote playback">
                initiating remote playback</a>, then:
                <ol>
                  <li>Reject <var>promise</var> with a <a>NotSupportedError</a>
                  exception.
                  </li>
                  <li>Abort all remaining steps.
                  </li>
                </ol>
              </li>
              <li>Let <var>callbackId</var> be a positive integer unique among
                all the <var>callbackIds</var> previously returned by these steps
                in the <a>browsing context</a> of the <a>media element</a>.
              </li>
              <li>Create a tuple <em>(<var>callbackId</var>,
              <var>callback</var>)</em> and add it to the <a>set of
              availability callbacks</a> for this <a>media element</a>.
              </li>
              <li>Fulfill <var>promise</var> with the <var>callbackId</var> and
              run the following steps <a>in parallel</a>:
                <ol>
                  <li>
                    <a>Queue a task</a> to invoke the <var>callback</var> with
                    the current <a>availability</a> for the <a>media
                    element</a>.
                  </li>
                  <li>If the <a>user agent</a> is not <a data-lt=
                  "monitor the list of available remote playback devices">monitoring
                  the list of available remote playback devices</a>, run the
                  algorithm to <a>monitor the list of available remote playback
                  devices</a>.
                  </li>
                </ol>
              </li>
            </ol>
            <p class="note">
              A simple algorithm for assigning <var>callbackId</var> values is
              to keep a counter for each <a>browsing context</a> and
              incrementing it in step 6.
            </p>
            <div class="note">
              To avoid leaking information that could fingerprint the user, the
              user agent SHOULD NOT assign a <var>callbackId</var> that uses any
              persistent information from the browser profile or a <a>remote
              playback device</a>.
            </div>
          </section>
          <section>
            <h5>
              Monitoring the list of available remote playback devices
            </h5>
            <p>
              If the <a>set of availability callbacks</a> is non-empty, or
              there is a pending request to <a data-link-for="RemotePlayback"
              data-lt="prompt">initiate remote playback</a>, the <a>user
              agent</a> MUST <dfn>monitor the list of available remote playback
              devices</dfn> by running the following steps:
            </p>
            <ol>
              <li>Retrieve available remote playback devices (using an
              implementation specific mechanism) and let <var>newDevices</var>
              be this list.
              </li>
              <li>For each <a>media element</a> known to the <a>browsing
              context</a>:
                <ol>
                  <li>If the <a data-link-for=
                  "HTMLMediaElement">disableRemotePlayback</a> attribute is
                  present for <var>mediaElement</var>, abort all the remaining
                  steps for this tuple and continue to the next one.
                  </li>
                  <li>Set <var>newAvailabilityValue</var> to the value of
                  <a>availability</a> for the <a>media element</a> calculated
                  using the <var>newDevices</var> list instead of the <a>list
                  of available remote playback devices</a>.
                  </li>
                  <li>If the current <a>availability</a> is not equal to <var>
                    newAvailabilityValue</var>, then for each
                    <em>(<var>callbackId</var>, <var>callback</var>)</em> of
                    the element's <a>set of availability callbacks</a>:
                    <ol>
                      <li>
                        <a>Queue a task</a> to invoke <var>callback</var> with
                        <var>newAvailabilityValue</var> as its argument.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Set the <a>list of available remote playback devices</a> to
              the value of <var>newDevices</var>.
              </li>
            </ol>
          </section>
          <section>
            <h5>
              Stop observing remote playback devices availability
            </h5>
            <p>
              When a <code><dfn data-dfn-for=
              "RemotePlayback">cancelWatchAvailability</dfn>()</code> method is
              called, the <a>user agent</a> MUST run the following steps:
            </p>
            <dl>
              <dt>
                Input
              </dt>
              <dd>
                <var>id</var>, the callback identifier.
              </dd>
              <dt>
                Output
              </dt>
              <dd>
                <var>promise</var>, a promise.
              </dd>
            </dl>
            <ol>
              <li>Let <var>promise</var> be a new promise.
              </li>
              <li>Return <var>promise</var>, and run the following steps below:
              </li>
              <li>If the <a data-link-for=
              "HTMLMediaElement">disableRemotePlayback</a> attribute is present
              for the <a>media element</a>, reject <var>promise</var> with <a>
                InvalidStateError</a> and abort all the remaining steps.
              </li>
              <li>If the parameter <var>id</var> is <code>undefined</code>,
              clear the <a>set of availability callbacks</a>.
              </li>
              <li>Otherwise, if <var>id</var> matches the <var>callbackId</var>
              for any entry in the <a>set of availability callbacks</a>, remove
              the entry from the set.
              </li>
              <li>Otherwise, reject <var>promise</var> with
              <a>NotFoundError</a> and abort all the remaining steps.
              </li>
              <li>If the <a>set of availability callbacks</a> is now empty and
              there is no pending request to <a data-link-for="RemotePlabyack"
                data-lt="prompt">initiate remote playback</a>, cancel any
                pending task to <a>monitor the list of available remote
                playback devices</a> for power saving purposes.
              </li>
              <li>Fulfill <var>promise</var>.
              </li>
            </ol>
            <div class="note">
              The mechanism used to monitor <a>remote playback devices</a>
              availability and determine the compatibility of a <a>remote
              playback device</a> with the selected <a>availability sources
              set</a> is left to the user agent.
            </div>
          </section>
        </section>
        <section>
          <h4>
            Prompt user for changing remote playback state
          </h4>
          <p>
            When the <code><dfn data-dfn-for=
            "RemotePlayback">prompt</dfn>()</code> method is called, the
            <a>user agent</a> MUST run the following steps:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              None, but the algorithm references the <a>media element</a>, its
              <a data-lt="RemotePlayback">remote</a> property and its
              <a>availability sources set</a>.
            </dd>
            <dt>
              Output
            </dt>
            <dd>
              A promise.
            </dd>
          </dl>
          <ol>
            <li>Let <var>promise</var> be a new promise.
            </li>
            <li>Return <var>promise</var> and continue running these steps <a>
              in parallel</a>.
            </li>
            <li>If the <a data-link-for=
            "HTMLMediaElement">disableRemotePlayback</a> attribute is present
            for the <a>media element</a>, reject the <var>promise</var> with
            <a>InvalidStateError</a> and abort all the remaining steps.
            </li>
            <li>If there is already an unsettled promise from a previous call
            to <a data-link-for="RemotePlayback">prompt</a> for the same
            <a>media element</a> or even for the same <a>browsing context</a>,
            the user agent MAY reject <var>promise</var> with an
            <a>OperationError</a> exception and abort all remaining steps.
              <div class="note">
                The rationale here is that the user agent might show a dialog
                that's modal to either the <a>media element</a> or the
                <a>browsing context</a>. In such a case, the second call to
                <code><a data-link-for="RemotePlayback">prompt</a>()</code>
                would not be able to show any UI.
              </div>
            </li>
            <li>If the algorithm isn't <a>allowed to show a popup</a>, reject
            <var>promise</var> with an <a>InvalidAccessError</a> exception and
            abort these steps.
            </li>
            <li>OPTIONALLY, if the <a>user agent</a> knows a priori that remote playback
            of this particular <a>media element</a> is not feasible
            (independent of the current
            <code><a data-link-for="RemotePlayback">state</a></code> or
            the <a>list of available remote playback devices</a>),
            reject <var>promise</var> with a <a>NotSupportedError</a> and abort
            all remaining steps.
              <div class="note">
                An example of this situation is when the user agent only
                supports <a>media flinging</a>, and the media element's source
                is not a <a>URL</a> that can be passed to a
                <a>remote playback device</a>.
              </div>
            </li>
            <li>If the <a>user agent</a> needs to show the <a>list of available
            remote playback devices</a> and is not <a data-lt=
            "monitor the list of available remote playback devices">monitoring
            the list of available remote playback devices</a>, run the steps to
            <a>monitor the list of available remote playback devices</a> <a>in
            parallel</a>.
            </li>
            <li>If remote playback is <a>unavailable</a> and will remain so
            before the request for user permission is complete,
            reject <var>promise</var> with a <a>NotFoundError</a> exception and
            abort all remaining steps.
            </li>
            <li>Request user a permission to <dfn>change remote playback
            state</dfn>.
              <div class="note">
                An example would be showing UI that allows the user to pick a
                <a>remote playback device</a> or switch between the local or
                remote playback devices or has a button to <a>disconnect from
                a remote playback device</a>.
              </div>
            </li>
            <li>If the user picked a <a>remote playback device</a>
            <var>device</var> to <dfn>initiate remote playback</dfn> with, the
            <a>user agent</a> MUST run the following steps:
              <ol>
                <li>Set the <a data-link-for="RemotePlayback">state</a> of the
                <var>remote</var> object to <a data-link-for=
                "RemotePlaybackState">connecting</a>.
                </li>
                <li>Fulfill <var>promise</var>.
                </li>
                <li>
                  <a>Queue a task</a> to <a>fire a simple event</a> with the
                  name <a>connecting</a> at the <a data-lt=
                  "RemotePlayback">remote</a> property of the <a>media
                  element</a>. The event must not bubble, must not be
                  cancelable, and has no default action.
                </li>
                <li>
                  <a>Establish a connection with the remote playback device</a>
                  <var>device</var> for the <a>media element</a>.
                </li>
              </ol>
              <p class="note">
                By picking a <a>remote playback device</a> the user <em>grants
                permission</em> to use the device.
              </p>
            </li>
            <li>Otherwise, if the user chose to disconnect from the <a>remote
            playback device</a> <var>device</var>, the <a>user agent</a> MUST
            run the following steps:
              <ol>
                <li>Fulfill <var>promise</var>.
                </li>
                <li>Run the <a>disconnect from a remote playback device</a>
                algorithm for the <var>device</var>.
                </li>
              </ol>
            </li>
            <li>Otherwise, the user is considered to <em>deny permission</em>
            to use the device, so reject <var>promise</var> with
            <a>NotAllowedError</a> exception and hide the UI shown by the
            <a>user agent</a>
            </li>
          </ol>
          <div class="note">
            The details of implementing the UI and device selection are left to
            the user agent; for example it MAY show the user a dialog and allow
            the user to select an available device (<em>granting
            permission</em>), or cancel the selection (<em>denying
            permission</em>).
          </div>
          <div class="note">
            The algorithm to select the <a>remote playback source</a> for a
            selected device depends on the user agent and supported <a>remote
            playback device</a> types. For example, in case of <a>media
            mirroring</a> the user agent can simply follow the
            <a>HTMLMediaElement</a>'s <a>resource selection algorithm</a>.
            However, if <a>media remoting</a> or <a>media flinging</a> is used,
            the best media source can depend on the selected <a>remote playback
            device</a> fetch and playback capabilities.
          </div>
        </section>
        <section>
          <h4>
            The <code><a data-link-for="RemotePlayback">state</a></code>
            attribute
          </h4>
          <p>
            The <dfn data-dfn-for="RemotePlayback"><code>state</code></dfn>
            attribute represents the <a>RemotePlayback</a> connection's current
            state. It can take one of the values of <a>RemotePlaybackState</a>
            depending on the connection state:
          </p>
          <ul data-dfn-for="RemotePlaybackState">
            <li>
              <dfn>connecting</dfn> means that the user agent is attempting to
              <a>initiate remote playback</a> with the selected <a>remote
              playback device</a>. This is the initial state when the
              <code>promise</code> returned by <code><a data-link-for=
              "RemotePlayback">prompt</a>()</code> is fulfilled. The local
              playback of the media element continues in this state and media
              commands still take effect on the <a>local playback state</a>.
            </li>
            <li>
              <dfn>connected</dfn> means that the transition from local to
              remote playback has finished and all media commands now take
              effect on the <a>remote playback state</a>.
            </li>
            <li>
              <dfn>disconnected</dfn> means that the remote playback has not
              been <a data-lt="initiate remote playback">initiated</a>, has
              failed to initiate or has been stopped. All media commands will
              take effect on the <a>local playback state</a>. The remote
              playback can be initiated through a call to
              <code><a data-link-for="RemotePlayback">prompt</a>()</code>.
            </li>
          </ul>
        </section>
        <section>
          <h4>
            Establishing a connection with a remote playback device
          </h4>
          <p>
            When the <a>user agent</a> is to <dfn>establish a connection with
            the remote playback device</dfn>, it MUST run the following steps:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>remote</var>, the <a>RemotePlayback</a> object that is to be
              connected.
            </dd>
            <dd>
              <var>device</var>, the <a>remote playback device</a> to connect
              to.
            </dd>
          </dl>
          <ol>
            <li>If the <a data-link-for="RemotePlayback">state</a> of
            <var>remote</var> is not equal to <a data-link-for=
            "RemotePlaybackState">connecting</a>, abort all the remaining
            steps.
            </li>
            <li>Request connection of <var>remote</var> to <var>device</var>.
            The implementation of this step is specific to the <a>user
            agent</a>.
            </li>
            <li>If connection completes successfully, <a>queue a task</a> to
            run the following steps:
              <ol>
                <li>Set the <a data-link-for="RemotePlayback">state</a> of
                <var>remote</var> to <a data-link-for=
                "RemotePlaybackState">connected</a>.
                </li>
                <li>
                  <a>Fire a simple event</a> named <a>connect</a> at
                  <var>remote</var>.
                </li>
                <li>Synchronize the current <a>media element state</a> with the
                <a>remote playback state</a>. Implementation is specific to <a>
                  user agent</a>.
                </li>
              </ol>
            </li>
            <li>If connection fails, <a>queue a task</a> to run the following
            steps:
              <ol>
                <li>Set the <a data-link-for="RemotePlayback" data-lt="state">
                  remote playback state</a> of <var>remote</var> to
                  <a data-link-for="RemotePlaybackState">disconnected</a>.
                </li>
                <li>
                  <a>Fire a simple event</a> named <a>disconnect</a> at
                  <var>remote</var>.
                </li>
              </ol>
            </li>
          </ol>
          <div class="note">
            The mechanism that is used to connect the user agent with the
            <a>remote playback device</a> and play the <a>remote playback
            source</a> is an implementation choice of the user agent. The
            connection will likely have to provide a two-way messaging
            abstraction capable of carrying media commands to the remote
            playback device and receiving media playback state in order to keep
            the <a>media element state</a> and <a>remote playback state</a> in
            sync (unless <a>media mirroring</a> is used).
          </div>
          <div class="note">
            The user agent SHOULD pause local audio and video output of the
            media element while the <a>remote playback state</a>
            is <a data-link-for="RemotePlaybackState">connected</a>.
          </div>
          <div class="note">
            If the user agent is <a>exposing a user interface to the user</a>
            for the media element (i.e., using default controls), the user agent
            SHOULD convey the fact that the <a>remote playback state</a>
            is <a data-link-for="RemotePlaybackState">connected</a> through an
            icon or other means.
          </div>
        </section>
        <section>
          <h4>
            Browser initiated remote playback
          </h4>
          <p>
            A user agent MAY support <a data-lt=
            "establish a connection with the remote playback device">connecting
            to a remote playback device</a> from the browser, e.g. by including
            appropriate controls to <a data-lt=
            "expose a user interface to the user">the user interface that is
            exposed to the user</a>. This feature is known as <dfn>browser
            initiated remote playback</dfn>. A <a>user agent</a> that supports
            <a>browser initiated remote playback</a> SHOULD initiate the remote
            playback only when the user has expressed an intention to do so via
            a user gesture, for example by clicking a button in the browser.
          </p>
          <p>
            If the user agent supports <a>browser initiated remote
            playback</a>, it MUST support the <a data-link-for=
            "RemotePlayback">state</a> attribute and the corresponding events
            by following the algorithms to <a>establish a connection with the
            remote playback device</a> and <a>disconnect from a remote playback
            device</a>.
          </p>
        </section>
        <section>
          <h4>
            Media commands and media playback state
          </h4>
          <p>
            The <a>HTMLMediaElement</a> interface interacts with the remotely
            played media as soon as the connection with the <a>remote playback
            device</a> is established.
          </p>
          <p>
            In particular, as soon as the <a data-link-for=
            "RemotePlayback">state</a> of a <a>RemotePlayback</a> object has
            changed to <a data-link-for="RemotePlaybackState">connected</a>,
            the <a>user agent</a> MUST send all the media commands issued on
            the <a>HTMLMediaElement</a> object with which the
            <a>RemotePlayback</a> object is associated to the <a>remote
            playback device</a> in order to change the <a>remote playback
            state</a> vs the <a>local playback state</a>.
          </p>
          <p>
            Similarly, the <a>user agent</a> MUST reflect all updates of the
            <a>remote playback state</a> received from the <a>remote playback
            device</a> on the <a>media element state</a>.
          </p>
          <p>
            If sending any command fails, the <a>user agent</a> MAY
            <a>disconnect from a remote playback device</a>.
          </p>
          <div class="note">
            <p>
              The <a>remote playback device</a> can implement a subset
              of the capabilities of the playback engine of the user
              agent, and some <a>HTMLMediaElement</a> APIs do not always
              make sense to use during remote playback. In this case, the
              <a>local playback state</a> is expected to reflect as closely
              as possible the actual <a>remote playback state</a> after a
              media command that is not supported during remote playback.
            </p>
            <p>
              For example, after calling <code><a>fastSeek</a>()</code> while
              connected to a <a>remote playback device</a> that does not
              support it, the <code><a>seeking</a></code> attribute of the
              <a>HTMLMediaElement</a> is expected to remain <code>false</code>
              and no <code>seeking</code> event is to be fired.
            </p>
          </div>
        </section>
        <section>
          <h4>
            Disconnecting from a remote playback device
          </h4>
          <p>
            When the <a>user agent</a> is to <dfn>disconnect from a remote
            playback device</dfn>, it MUST do the following:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>remote</var>, the <a>RemotePlayback</a> object representing
              the playback to be stopped.
            </dd>
            <dd>
              <var>device</var>, the <a>remote playback device</a> to
              disconnect from.
            </dd>
          </dl>
          <ol>
            <li>If the <a data-link-for="RemotePlayback"><code>state</code></a>
            of <var>remote</var> is <code>disconnected</code>, abort all
            remaining steps.
            </li>
            <li>
              <a>Queue a task</a> to run the following steps:
              <ol>
                <li>Request disconnection of <var>remote</var> from the
                <var>device</var>. Implementation is <a>user agent</a>
                specific.
                </li>
                <li>Change the <var>remote</var>'s <code>state</code> to <code>
                  disconnected</code>.
                </li>
                <li>
                  <a data-lt="fire">Fire an event</a> with the name
                  <a>disconnect</a> at <var>remote</var>.
                </li>
                <li>Synchronize the current <a>media element state</a> with the
                <a>local playback state</a>. Implementation is specific to <a>
                  user agent</a>.
                </li>
              </ol>
            </li>
          </ol>
          <div class="note">
            The remote playback device might not actually stop playback of the
            media when requested by the user agent since it's implementation
            specific and depends on the device in question. In such case
            stopping remote playback merely means the user agent literally only
            disconnecting from the remote playback device and the <a>media
            element</a> switching to the <code>disconnected</code> state.
          </div>
          <div class="note">
            If the remote playback device is abruptly disconnected during
            playback (for example, by power loss or a network disconnection),
            the user agent SHOULD run the steps to <a>monitor the list of
            available remote playback devices</a> before the steps
            to <a>disconnect from a remote playback device</a>.  This allows
            callbacks in the <a>set of availability callbacks</a> to be invoked
            before the <a>disconnect</a> event is fired, so the page can update
            itself to show resumption of playback is not possible.
          </div>
        </section>
        <section>
          <h4>
            Event Handlers
          </h4>
          <p>
            The following are the event handlers (and their corresponding event
            handler event types) that must be supported, as <a>event
            handler</a> IDL attributes, by objects implementing the
            <a>RemotePlayback</a> interface:
          </p>
          <table data-dfn-for="RemotePlayback">
            <thead>
              <tr>
                <th>
                  Event handler
                </th>
                <th>
                  Event handler event type
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <dfn><code>onconnecting</code></dfn>
                </td>
                <td>
                  <dfn><code>connecting</code></dfn>
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code>onconnect</code></dfn>
                </td>
                <td>
                  <dfn><code>connect</code></dfn>
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code>ondisconnect</code></dfn>
                </td>
                <td>
                  <dfn><code>disconnect</code></dfn>
                </td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section>
        <h3>
          Extension to the <code><a>HTMLMediaElement</a></code>
        </h3>
        <pre class='idl'>
          partial interface HTMLMediaElement {
            [SameObject] readonly attribute RemotePlayback remote;

            [CEReactions] attribute boolean disableRemotePlayback;
          };
        </pre>
        <p>
          The <dfn data-dfn-for='HTMLMediaElement'>remote</dfn> attribute MUST
          return the <a>RemotePlayback</a> instance associated with the
          <a>media element</a>.
        </p>
        <p>
          The <dfn data-dfn-for='HTMLMediaElement'>disableRemotePlayback</dfn>
          IDL attribute MUST reflect the content attribute of the same name.
        </p>
        <section>
          <h4>
            Disabling remote playback
          </h4>
          <p>
            If the <a data-link-for=
            'HTMLMediaElement'>disableRemotePlayback</a> attribute is present
            on the <a>media element</a>, the <a>user agent</a> MUST NOT play
            the media remotely or present any UI to do so.
          </p>
          <p>
            When the <a data-link-for=
            'HTMLMediaElement'>disableRemotePlayback</a> attribute is added to
            the <a>media element</a>, the user agent MUST run the steps
            to <dfn>disable remote playback</dfn>:
          </p>
          <ol>
            <li>Reject any pending promises returned by the
            <a>RemotePlayback</a> methods with <a>InvalidStateError</a>.
            </li>
            <li>Clear the <a>set of availability callbacks</a> for the media
            element.
            </li>
            <li>If its <a data-link-for="RemotePlayback">state</a> is not
            <code>disconnected</code>, run the <a>disconnect from a remote
            playback device</a> algorithm for the <a>remote playback device</a>
            the media element is connected or connecting to.
            </li>
          </ol>
          <p></p>
        </section>
      </section>
    </section>
    <section class="informative">
      <h2>
        Security and privacy considerations
      </h2>
      <section>
        <h3>
          Personally identifiable information
        </h3>
        <p>
          Firing the <code>callback</code> provided via the
          <code><a data-link-for=
          "RemotePlayback">watchAvailability</a>()</code> method reveals one
          bit of information about the presence (or non-presence) of a
          <a>remote playback device</a> typically discovered through the local
          area network. This could be used in conjunction with other
          information for fingerprinting the user. However, this information is
          also dependent on the user's local network context, so the risk is
          minimized.  Also, by design, the human readable name of a <a>remote
          playback device</a> is not revealed to the page.
        </p>
        <p>
          The API enables <a href=
          "#monitoring-the-list-of-available-presentation-displays">monitoring
          the list of available remote playback devices</a>. How the user agent
          determines the compatibility and availability of a <a>remote playback
          device</a> with a <a>media element</a>'s <a data-lt=
          "media resource">resource</a> is an implementation detail. If a
          <a>user agent</a> matches a <a>media resource</a> to a particular
          type of device to determine its availability, this feature can be
          used to probe information about which <a>remote playback device</a>
          the user has without user consent.
        </p>
        <p>
          The user agent SHOULD NOT <a>monitor the list of available remote
          playback devices</a> if the user disables background monitoring
          through a browser setting.
        </p>
      </section>
      <section>
        <h3>
          User interface guidelines
        </h3>
        <dl>
          <dt>
            Origin display
          </dt>
          <dd>
            <p>
              When the user is asked permission to use a <a>remote playback
              device</a> during the steps to <a>change remote playback
              state</a>, the user agent should make it clear what origin the
              request is coming from.
            </p>
            <p>
              Display of the origin requesting remote playback will help the
              user understand what content is making the request, especially
              when the request is initiated from a <a>nested browsing
              context</a>. For example, embedded content may try to convince
              the user to click to trigger a request to start an unwanted
              remote playback.
            </p>
            <p>
              Showing the origin that will be presented will help the user know
              if that content is from an <a>potentially secure</a> (e.g.,
              <code>https:</code>) origin, and corresponds to a known or
              expected site.
            </p>
          </dd>
        </dl>
      </section>
      <section>
        <h3>
          Device Access
        </h3>
        <p>
          The Remote Playback API abstracts away what "local" means for
          displays, meaning that it exposes network-accessible displays as
          though they were local displays. The Remote Playback API requires
          user permission for a page to access any display to mitigate issues
          that could arise, such as showing unwanted content on a display
          viewable by others.
        </p>
      </section>
      <section>
        <h3>
          Messaging between the local and remote playback devices
        </h3>
        <p>
          This spec will not mandate communication protocols between the
          <a>local playback device</a> and the <a>remote playback device</a>,
          but it should set some guarantees of message confidentiality and
          authenticity between them.
        </p>
      </section>
    </section>
    <section class="appendix">
      <h2>
        Candidate Recommendation exit criteria
      </h2>
      <p>
        For this specification to be advanced to Proposed Recommendation, there
        must be at least two independent, interoperable implementations of each
        feature. Each feature may be implemented by a different set of
        products, there is no requirement that all features be implemented by a
        single product. Additionally, implementations must demonstrate support
        for the <a>media remoting</a> and <a>media flinging</a> cases, either
        within the same product or within different products.
      </p>
      <p>
        For the purposes of these criteria, we define the following terms:
      </p>
      <dl>
        <dt>
          Independent
        </dt>
        <dd>
          Each implementation must be developed by a different party, and
          cannot share, reuse, or derive from code used by another qualifying
          implementation. Sections of code that have no bearing on the
          implementation of this specification are exempt from this
          requirement.
        </dd>
        <dt>
          Interoperable
        </dt>
        <dd>
          Passing the respective test case(s) in the official test suite.
        </dd>
        <dt>
          Implementation
        </dt>
        <dd>
          A user agent which:
          <ol>
            <li>implements the specification.
            </li>
            <li>is available to the general public. The implementation may be a
            shipping product or other publicly available version (i.e., beta
            version, preview release, or "nightly build"). Non-shipping product
            releases must have implemented the feature(s) for a period of at
            least one month in order to demonstrate stability.
            </li>
            <li>is not experimental (i.e. a version specifically designed to
            pass the test suite and not intended for normal usage going
            forward).
            </li>
          </ol>
        </dd>
      </dl>
    </section>
  </body>
</html>
