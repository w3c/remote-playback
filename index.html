<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <title>
      Remote Playback API
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" async
    class="remove">
    </script>
    <script class="remove">
    var respecConfig = {
        specStatus: 'ED',
        edDraftURI: 'https://w3c.github.io/remote-playback/',
        shortName:  'remote-playback',
        editors: [
          {
            w3cid: 68811,
            name: 'Anton Vayvod',
            company: 'Google',
          },
          {
            w3cid: 45389,
            name: 'Mounir Lamouri',
            company: 'Google',
          },
        ],
        // previousMaturity: 'WD',
        // previousPublishDate: '2015-11-02',
        otherLinks: [
          {
            key: 'Version history',
            data: [
              {
                value: 'GitHub w3c/remote-playback/commits',
                href: 'https://github.com/w3c/remote-playback/commits/'
              }
            ]
          },
          {
            key: 'Participate',
            data: [
              {
                value: 'GitHub w3c/remote-playback',
                href: 'https://github.com/w3c/remote-playback/'
              },
              {
                value: 'File an issue',
                href: 'https://github.com/w3c/remote-playback/issues/new'
              },
              {
                value: 'Open issues',
                href: 'https://github.com/w3c/remote-playback/issues/'
              },
              {
                value: 'Mailing-list (public-secondscreen@w3.org)',
                href: 'https://lists.w3.org/Archives/Public/public-secondscreen/'
              }
            ]
          }
        ],
        wg: 'Second Screen Presentation Working Group',
        wgURI: 'https://www.w3.org/2014/secondscreen/',
        wgPublicList: 'public-secondscreen',
        wgPatentURI: 'https://www.w3.org/2004/01/pp-impl/74168/status',
        issueBase: "https://www.github.com/w3c/remote-playback/issues/",
        githubAPI: "https://api.github.com/repos/w3c/remote-playback",
      };
    </script>
    <style>
    /* Note formatting taken from Presentation API spec for consistency in the
       Second Screen WG */
    .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    .note em, .warning em, .note i, .warning i { font-style: normal; }
    p.note, div.note { padding: 0.5em 2em; }
    span.note { padding: 0 2em; }
    .note p:first-child { margin-top: 0; }
    .note p:last-child { margin-bottom: 0; }
    p.note:before { content: 'NOTE: '; }
    .non-normative { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    p.non-normative:before { content: 'Non-normative: '; font-weight: bolder;}
    p.non-normative, div.non-normative { padding: 0.5em 2em; }
    /* Pre.idl formatting taken from HTML5 spec */
    pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
    pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
    pre.idl::before { content: "IDL"; font: bold small sans-serif;
    padding: 0.5em; background: white; position: absolute; top: 0;
    margin: -1px 0 0 -4em; width: 1.5em; border: thin solid;
    border-radius: 0 0 0 0.5em }
    /* .example idl formatting taken from HTML5 nightly spec */
    .example {
        display: block;
        color: #222222;
        background: #FCFCFC;
        border-left-style: solid;
        border-color: #c0c0c0;
        border-left-width: 0.25em;
        margin-left: 1em;
        padding-left: 1em;
        padding-bottom: 0.5em;
    }
    .algorithm li {
        margin-bottom: 0.5em;
    }
    .interface dd, .parameters dt {
        margin-bottom: 0.5em;
    }
    code { color: orangered; }
    table { border-collapse: collapse; border-style: hidden hidden none hidden; }
    table thead, table tbody { border-bottom: solid; }
    table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    dfn { font-weight: bolder; font-style: normal; }
    .copyright { font-size: small; }
    .issue[id^='issue-'] > *:not([role='heading']) { display: none; }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This specification defines an API extending the <code><a>HTMLMediaElement</a></code>
        that enables controlling remote playback of media from a web page.
      </p>
    </section>
    <section id="sotd">
      <p>
        This document is a work in progress and is subject to change. In case of
        issues or concerns, it is possible to <a href='https://github.com/w3c/remote-playback/issues/new'>file a bug</a>
        or send an email to the <a href='https://lists.w3.org/Archives/Public/public-secondscreen/'>mailing list</a>.
        For small editorial changes like typos, sending a pull requests is appreciated.
      </p>
    </section>
    <section id='conformance'>
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to expose the APIs defined in this
        specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]].
      </p>
    </section>
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        This specification aims to make <a>remote playback devices</a> such as
        connected TVs, projectors or audio-only speakers, available to the Web and
        takes into account displays that are attached using wired (HDMI, DVI,
        or similar) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, or
        similar).
      </p>
      <p>
        Devices with limited screen size or quiet speakers lack the ability to
        playback media content to a larger audience, for example, a group of
        colleagues in a conference room, or friends and family at home. Playing media
        content on an external larger and/or louder <a>remote playback device</a> helps
        to improve the perceived quality and impact of the played media.
      </p>
      <p>
        At its core, this specification enables a page that acts as the <a>controller</a>
        to initiate and control remote playback of a particular media element on a selected
        <a>remote playback device</a>. How the remoting is initiated and controlled
        is left to the UA in order to allow the use of <a>remote playback devices</a> that
        can be attached in a wide variety of ways. For example, when a <a>remote playback device</a>
        is attached using HDMI or Miracast, the same UA that acts as the
        <a>controller</a> renders the remote media. Instead of playing the media on the same
        device, however, it can use whatever means the operating system provides for using
        the external <a>remote playback device</a>. In such a case, both the <a>controller</a> and
        the media player run on the same UA and the operating system is used to route the player
        output to the <a>remote playback device</a>. This is commonly referred to as the
        <dfn><b id="1-ua">1-UA</b></dfn> case. This specification imposes no requirements on the
        <a>remote playback devices</a> connected in such a manner.
      </p>
      <p>
        If the <a>remote playback device</a> is able to play the media and
        communicate with the <a>controller</a>, the <a>controller</a> does not
        need to render the remoted media. In this case, the UA acts as a proxy
        that requests the <a>remote playback device</a> to play the media itself by passing the necessary
        data like a URL to the media file or encoded media frames. This is commonly referred to as
        the <b id="2-ua">2-UA</b> case. This way of attaching to displays could be enhanced in the future by
        defining a standard protocol for delivering these types of messages that remote playback devices could choose
        to implement.
      </p>
      <p>
        The API defined here is intended to be used with UAs that attach to
        <a>remote playback device</a> devices through any of the above means.
      </p>
    </section>
    <section class='informative'>
      <h2>Use cases and requirements</h2>
      <p>
        The use cases and requirements of this specification are captured in a
        separate document available <a href='https://github.com/w3c/remote-playback/blob/gh-pages/use-cases.md'>here</a>.
      </p>
    </section>
    <section>
      <h2>Dependencies</h2>
      <p>
        The following concepts and interfaces are defined in [[!HTML]]:
      </p>
      <ul>
        <li>
          <dfn><a href=
          'https://html.spec.whatwg.org/multipage/embedded-content.html#htmlmediaelement'>HTMLMediaElement</a></dfn>
        </li>
        <li>
          <dfn><a href='https://html.spec.whatwg.org/multipage/embedded-content.html#media-element'>media element</a></dfn>
        </li>
      </ul>
    </section>
    <section>
      <h2>
        Examples
      </h2>
      <p>
        This section shows the code examples that highlight the usage of the main features of the Remote Playback API.
        In these examples, <code>player.html</code> implements the player page controlling the remote playback and
        <code>media.ext</code> is the media file to be played remotely. Both the page and the media are served from the
        domain <code>https://example.org</code>. Please refer to the comments in the code examples for further details.
      </p>
      <section>
        <h3>
          Monitor availability of remote playback devices example
        </h3>
        <pre class="example highlight">
&lt;!-- player.html --&gt;
&lt;!-- The video element with custom controls that supports remote playback. --&gt;
&lt;video src="https://example.org/video.ext" /&gt;
&lt;button id="remotePlaybackBtn" style="display: none;"&gt;Play remotely&lt;/button&gt;
&lt;script&gt;
  // The "Play remotely" button is visible if at least one remote playback device is available.
  var remotePlaybackBtn = document.querySelector("video");
  // Show or hide the remote playback button depending on device availability.
  var handleAvailabilityChange = function(available) {
    remotePlaybackBtn.style.display = available ? "inline" : "none";
  };
  var videoElem = document.getElementById("videoElement");
  // Promise is resolved as soon as the remote playback device availability is known.
  videoElem.remote.getAvailability().then(function(availability) {
    // availability.value may be kept up-to-date by the controlling UA as long
    // as the availability object is alive. It is advised for the web developers
    // to discard the object as soon as it's not needed.
    handleAvailabilityChange(availability.value);
    availability.onchange = function() { handleAvailabilityChange(this.value); };
  }).catch(function() {
    // Availability monitoring is not supported by the platform, so discovery of
    // remote playback devices will happen only after remote.connect() is called.
    // Pretend the devices are available for simplicity; or, one could implement
    // a third state for the button.
    handleAvailabilityChange(true);
  });
&lt;/script&gt;  
        </pre>
      </section>
      <section>
        <h3>
          Starting remote playback of a video example
        </h3>
        <pre class="example highlight">
&lt;!-- player.html --&gt;
&lt;script&gt;
  remotePlaybackBtn.onclick = function () {
    // Start remote playback.
    videoElem.remote.connect()
      // Update the UI and monitor the connected state.
      .then(setupRemotePlayback);
      // Otherwise, the user cancelled the selection UI or no screens were found.
  };
&lt;script&gt;
        </pre>
      </section>
      <section>
        <h3>
          Monitoring remote playback state changes
        </h3>
        <pre class="example highlight">
&lt;!-- player.html --&gt;
&lt;script&gt;
  // The remote playback may be initiated by the user agent.
  if (videoElem.remote.state != 'disconnected')
    setupRemotePlayback();
  videoElem.remote.onstatechange = function(evt) {
    if (videoElem.remote.state != 'disconnected')
      setupRemotePlayback();
    else
      stopRemotePlayback();
  };
&lt;script&gt;
        </pre>
      </section>
    </section>
    <section>
      <h2><code><a>RemotePlayback</a></code> interface</h2>
      <pre class='idl'>
        interface RemotePlayback : EventTarget {
          Promise&lt;RemotePlaybackAvailability&gt; getAvailability();

          readonly attribute RemotePlaybackState state;

          // This method will show a UI for the user to pick a device.
          // Resolves with true if a device was picked and the UA is
          // connecting to it, with false if the user canceled the action,
          // rejects if there was an error of some kind.
          Promise&lt;bool&gt;connect();
        };

        enum RemotePlaybackState {
          "connecting",
          "connected",
          "disconnected"
        };
      </pre>
      <p>
        <b>Draft summary:</b><br>
        <ul>
          <li>getAvailability()'s promise resolves with a RemotePlaybackAvailability,
            similar to the function with same name in Presentation API.</li>
          <li>state returns the remote playback connection's current state.</li>
          <li>connect() should show the user agent's device picker if the connection
            is not yet established or being established.</li>
        </ul>
      </p>
    </section>
    <section>
      <h2><code><a>RemotePlaybackAvailability</a></code> interface</h2>
      <pre class='idl'>
        interface RemotePlaybackAvailability : EventTarget {
          readonly attribute boolean value;
          attribute EventHandler onchange;
        };
      </pre>
      <p>
        A <a><code>RemotePlaybackAvailability</code></a> object is associated with available <a>remote playback devices</a>
        and represents the <dfn>remote playback device availability</dfn> for the media element. If the user
        agent can <a>monitor the list of available remote playback devices</a> in the background (without
        a pending request to <code><a for="RemotePlayback">connect()</a></code>), the 
        <a><code>RemotePlaybackAvailability</a></code> object MUST be implemented by the user agent.
      </p>
      <p>
        The <dfn for="RemotePlaybackAvailability">value</dfn> attribute MUST return the last value it was set to.
        The value is updated by the <a>monitor the list of available remote playback devices</a> algorithm.
      </p>
      <p>
        The <dfn for="RemotePlaybackAvailability">onchange</dfn> attribute is an <a>event handler</a> which
        corresponding <a>event handler event type</a> is <dfn><code>change</code></dfn>.
      </p>
      <section>
        <h4>
          The set of availability objects
        </h4>
        <p>
          The <a>user agent</a> MUST keep track of the <dfn>set of
          availability objects</dfn> requested through the <code><a for=
          "RemotePlayback">getAvailability</a>()</code> method. The
          <a>set of availability objects</a> is represented as a set of
          tuples <em>(<var>A</var>, <var>availabilitySource</var>)</em>,
          initially empty, where:
        </p>
        <ol>
          <li>
            <var>A</var> is a live <a>RemotePlaybackAvailability</a> object;
          </li>
          <li>
            <var>availabilitySource</var> is the <a>source</a> of the media element
            when <code><a for="RemotePlayback">getAvailability</a>()</code> is called to
            create <var>A</var>.
          </li>
        </ol>
      </section>
      <section>
        <h4>
          The list of available remote playback devices
        </h4>
        <p>
          The <a>user agent</a> MUST keep a <dfn>list of available
          remote playback devices</dfn>. This current list of <a>remote playback devices</a>
          may be used for initiating remote playback, and is
          populated based on an implementation specific discovery mechanism.
          It is set to the most recent result of the algorithm to <a>monitor
          the list of available remote playback devices</a>.
        </p>
        <p>
          While there are live <a>RemotePlaybackAvailability</a> objects, the
          <a>user agent</a> MAY <a>monitor the list of available remote playback devices</a> continuously,
          so that pages can use the <a for="RemotePlaybackAvailability">value</a> property of a
          <a>RemotePlaybackAvailability</a> object to offer remote playback only
          when there are available devices. However, the <a>user agent</a>
          may not support continuous availability monitoring; for example,
          because of platform or power consumption restrictions. In this case
          the <a>Promise</a> returned by <code><a for="RemotePlayback">getAvailability</a>()</code>
          MUST be <a data-lt="reject">rejected</a> and the algorithm to <a>monitor
          the list of available remote playback devices</a> will only run as part of the
          <a>initiate remote playback</a> algorithm.
        </p>
        <p>
          When there are no live <a>RemotePlaybackAvailability</a> objects
          (that is, the <a>set of availability objects</a> is empty), user
          agents SHOULD NOT <a>monitor the list of available remote playback devices</a> to satisfy the
          <a>power saving non-functional requirement</a>. To further save power,
          the <a>user agent</a> MAY also keep track of whether the page
          holding a <a>RemotePlaybackAvailability</a> object is in the
          foreground. Using this information, implementation specific
          discovery of <a>remote playback devices</a> can be resumed or
          suspended.
        </p>
        <p>
          Some <a>remote playback devices</a> may only be able to display a
          subset of Web content because of functional, security or hardware
          limitations. Examples are set-top boxes, smart TVs or networked
          speakers capable of rendering only certain formats of video and/or audio.
          We say that such a device is a <dfn>compatible remote playback device</dfn> for a
          <a>media element source</a> if the <a>user agent</a> can
          reasonably guarantee that the remote playback of the media speficied by the source
          on that device will succeed.
        </p>
      </section>
      <section>
        <h4>
          Getting the <a>remote playback devices</a> availability information
        </h4>
        <p>
          When the <code><dfn for="RemotePlayback">getAvailability</dfn>()</code> method is
          called, the user agent MUST run the following steps:
        </p>
        <dl>
          <dt>
            Input
          </dt>
          <dd>
            <var>remote media source</var>, the <a>media element source</a> preferred for remote playback
          </dd>
          <dt>
            Output
          </dt>
          <dd>
            <var>P</var>, a <a>Promise</a>
          </dd>
        </dl>
        <ol>
          <li>Let <var>P</var> be a new <a>Promise</a>.
          </li>
          <li>Return <var>P</var>, but continue running these steps <a>in
          parallel</a>.
          </li>
          <li>If the user agent is unable to <a>monitor the list of available
          remote playback devices</a> for the entire lifetime of the browsing context
          (for instance, because the user has disabled this feature), then:
            <ol>
              <li>
                <a>Resolve</a> <var>P</var> with a new
                <code>RemotePlaybackAvailability</code> object with its
                <code>value</code> property set to <code>false</code>.
              </li>
              <li>Abort all the remaining steps.
              </li>
            </ol>
          </li>
          <li>If the user agent is unable to continuously <a>monitor the list
          of available remote playback devices</a> but can do it for a short period of time
          when initiating remote playback, then:
            <ol>
              <li>
                <a>Reject</a> <var>P</var> with a <a>NotSupportedError</a>
                exception.
              </li>
              <li>Abort all the remaining steps.
              </li>
            </ol>
          </li>
          <li>
            If there exists a tuple <em>(<var>A</var>,
            <var>remote media source</var>)</em> in the <a>set of availability
            objects</a>, then:
            <ol>
              <li>
                <a>Resolve</a> <var>P</var> with <var>A</var>.
              </li>
              <li>
                Abort all the remaining steps.
              </li>
            </ol>
          </li>
          <li>
            Let <var>A</var> be a new <code>RemotePlaybackAvailability</code>
            object with its <code>value</code> property set to
            <code>false</code> if the <a>list of available remote playback devices</a>
            is empty or none of them is a <a>compatible remote playback device</a>,
            <code>true</code> otherwise.
          </li>
          <li>
            Create a tuple <em>(<var>A</var>, <var>remote media source</var>)</em> and add it
            to the <a>set of availability objects</a>.
          </li>
          <li>Run the algorithm to <a>monitor the list of available remote playback devices</a>.
          </li>
          <li>
            <a>Resolve</a> <var>P</var> with <var>A</var>.
          </li>
        </ol>
      </section>
      <section>
        <h4>
          Monitoring the list of available remote playback devices
        </h4>
        <p>
          If the <a>set of availability objects</a> is non-empty, or there is
          a pending request to <a for="RemotePlayback" data-lt="connect">initiate remote playback</a>,
          the <a>user agent</a> MUST <dfn>monitor the list of available remote playback devices</dfn> by
          running the following steps:
        </p>
        <ol link-for="RemotePlaybackAvailability">
          <li>
            Retrieve available remote playback devices (using an implementation specific mechanism)
            and let <var>newDevices</var> be this list.
          </li>
          <li>
            For each member <em>(<var>A</var>, <var>availabilitySource</var>)</em>
            of the <a>set of availability objects</a>:
            <ol>
              <li>
                Set <var>previousAvailability</var> to the value of <var>A</var>'s <a>value</a> property.
              </li>
              <li>
                Let <var>newAvailability</var> be <code>true</code> if <var>newDevices</var> is not empty
                and at least one device in <var>newDevices</var> is a <a>compatible remote playback device</a>
                for <var>availabilitySource</var>. Otherwise, set <var>newAvailability</var> to <code>false</code>.
              </li>
              <li>
                If <var>previousAvailability</var> is not equal to <var>newAvailability</var>, then <a>queue a task</a>
                to run the following steps:
                <ol>
                  <li>
                    Set <var>A</var>'s <a>value</a> property to <var>newAvailability</var>.
                  </li>
                  <li>
                    <a>Fire a simple event</a> named <a>change</a> at <var>A</var>.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            Set the <a>list of available remote playback devices</a> to the value of <var>newDevices</var>.
          </li>
        </ol>
        <p>
          When a <a>RemotePlaybackAvailability</a> object is no longer alive
          (in other words, is eligible for garbage collection), the <a>user agent</a>
          SHOULD run the following steps:
        </p>
        <ol>
          <li>
            Find and remove any entry <em>(<var>A</var>, <var>availabilitySource</var>)</em> in the
            <a>set of availability objects</a> for the newly deceased <var>A</var>.
          </li>
          <li>
            If the <a>set of availability objects</a> is now empty and there is no pending request to
            <a for="RemotePlabyack" data-lt="connect">initiate remote playback</a>, cancel any pending task
            to <a>monitor the list of available remote playback devices</a> for power saving purposes.
          </li>
        </ol>
        <div class="note">
          The mechanism used to monitor <a>remote playback devices</a> availability and determine the
          compatibility of a <a>presentation display</a> with a given media element source is left to the user agent.
        </div>
      </section>
    </section>
    <section>
      <h2>Extension to the <code><a>HTMLMediaElement</a></code></h2>
      <pre class='idl'>
        partial interface HTMLMediaElement {
          readonly attribute RemotePlayback remote;

          [CEReactions] attribute boolean disableRemotePlayback;
        };
      </pre>
      <p>
        The <a for='HTMLMediaElement'>remote</a> attribute MUST return the <a>RemotePlayback</a>
        instance associated with the <a>media element</a>.
      </p>
      <p>
        The <a for='HTMLMediaElement'>disableRemotePlayback</a> IDL attribute
        MUST reflect the content attribute of the same name.
      </p>

      <section>
        <h2>Disabling remote playback</h2>
        <p>
          If the <code>disableRemotePlayback</code> attribute is present on the
          <a>media element</a>, the <a>user agent</a> MUST NOT play the media
          remotely or present any UI to do so.
        </p>
      </section>
    </section>
  </body>
</html>
