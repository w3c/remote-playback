<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <title>
      Remote Playback API
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" async
    class="remove">
    </script>
    <script class="remove">
    var respecConfig = {
        specStatus: 'ED',
        edDraftURI: 'https://w3c.github.io/remote-playback/',
        shortName:  'remote-playback',
        editors: [
          {
            w3cid: 68811,
            name: 'Anton Vayvod',
            company: 'Google',
          },
          {
            w3cid: 45389,
            name: 'Mounir Lamouri',
            company: 'Google',
          },
        ],
        // previousMaturity: 'WD',
        // previousPublishDate: '2015-11-02',
        otherLinks: [
          {
            key: 'Version history',
            data: [
              {
                value: 'GitHub w3c/remote-playback/commits',
                href: 'https://github.com/w3c/remote-playback/commits/'
              }
            ]
          },
          {
            key: 'Participate',
            data: [
              {
                value: 'GitHub w3c/remote-playback',
                href: 'https://github.com/w3c/remote-playback/'
              },
              {
                value: 'File an issue',
                href: 'https://github.com/w3c/remote-playback/issues/new'
              },
              {
                value: 'Open issues',
                href: 'https://github.com/w3c/remote-playback/issues/'
              },
              {
                value: 'Mailing-list (public-secondscreen@w3.org)',
                href: 'https://lists.w3.org/Archives/Public/public-secondscreen/'
              }
            ]
          }
        ],
        wg: 'Second Screen Presentation Working Group',
        wgURI: 'https://www.w3.org/2014/secondscreen/',
        wgPublicList: 'public-secondscreen',
        wgPatentURI: 'https://www.w3.org/2004/01/pp-impl/74168/status',
        issueBase: "https://www.github.com/w3c/remote-playback/issues/",
        githubAPI: "https://api.github.com/repos/w3c/remote-playback",
      };
    </script>
    <style>
    /* Note formatting taken from Presentation API spec for consistency in the
       Second Screen WG */
    .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    .note em, .warning em, .note i, .warning i { font-style: normal; }
    p.note, div.note { padding: 0.5em 2em; }
    span.note { padding: 0 2em; }
    .note p:first-child { margin-top: 0; }
    .note p:last-child { margin-bottom: 0; }
    p.note:before { content: 'NOTE: '; }
    .non-normative { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    p.non-normative:before { content: 'Non-normative: '; font-weight: bolder;}
    p.non-normative, div.non-normative { padding: 0.5em 2em; }
    .algorithm li {
        margin-bottom: 0.5em;
    }
    .interface dd, .parameters dt {
        margin-bottom: 0.5em;
    }
    code { color: orangered; }
    table { border-collapse: collapse; border-style: hidden hidden none hidden; }
    table thead, table tbody { border-bottom: solid; }
    table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    dfn { font-weight: bolder; font-style: normal; }
    .copyright { font-size: small; }
    .issue[id^='issue-'] > *:not([role='heading']) { display: none; }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This specification defines an API extending the <code><a>HTMLMediaElement</a></code>
        that enables controlling remote playback of media from a web page.
      </p>
    </section>
    <section id="sotd">
      <p>
        This document is a work in progress and is subject to change. In case of
        issues or concerns, it is possible to <a href='https://github.com/w3c/remote-playback/issues/new'>file a bug</a>
        or send an email to the <a href='https://lists.w3.org/Archives/Public/public-secondscreen/'>mailing list</a>.
        For small editorial changes like typos, sending a pull requests is appreciated.
      </p>
    </section>
    <section id='conformance'>
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to expose the APIs defined in this
        specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]].
      </p>
    </section>
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        This specification aims to make <dfn data-lt="remote playback device">remote playback devices</dfn> such as
        connected TVs, projectors or audio-only speakers, available to the Web and
        takes into account displays that are attached using wired (HDMI, DVI,
        or similar) and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, or
        similar).
      </p>
      <p>
        Devices with limited screen size or quiet speakers lack the ability to
        playback media content to a larger audience, for example, a group of
        colleagues in a conference room, or friends and family at home. Playing media
        content on an external larger and/or louder <a>remote playback device</a> helps
        to improve the perceived quality and impact of the played media.
      </p>
      <p>
        At its core, this specification enables a page that acts as the <a>controller</a>
        to initiate and control remote playback of a particular media element on a selected
        <a>remote playback device</a>. How the remoting is initiated and controlled
        is left to the UA in order to allow the use of <a>remote playback devices</a> that
        can be attached in a wide variety of ways. For example, when a <a>remote playback device</a>
        is attached using HDMI or Miracast, the same UA that acts as the
        <a>controller</a> renders the remote media. Instead of playing the media on the same
        device, however, it can use whatever means the operating system provides for using
        the external <a>remote playback device</a>. In such a case, both the <a>controller</a> and
        the media player run on the same UA and the operating system is used to route the player
        output to the <a>remote playback device</a>. This is commonly referred to as the
        <dfn><b id="media-mirroring">media mirroring</b></dfn> case. This specification imposes no requirements on the
        <a>remote playback devices</a> connected in such a manner.
      </p>
      <p>
        If the <a>remote playback device</a> is able to play the media and
        communicate with the <a>controller</a> but is unable to fetch the
        media, the <a>controller</a> needs to fetch the media data and pass
        it on to the <a>remote playback device</a> for rendering. This is
        commonly referred to as <dfn><b id="media-remoting">media remoting</b></dfn> case.
      </p>
      <p>
        If the <a>remote playback device</a> is able to fetch and play the media and
        communicate with the <a>controller</a>, the <a>controller</a> does not
        need to fetch or render the remoted media. In this case, the UA acts as a proxy
        that requests the <a>remote playback device</a> to play the media itself by passing the necessary
        data like the media source. This is commonly referred to as the <dfn><b id="media-flinging">media flinging</b></dfn> case.
        This way of attaching to displays could be enhanced in the future by defining a standard protocol for
        delivering these types of messages that remote playback devices could choose to implement.
      </p>
      <p>
        The API defined here is intended to be used with UAs that attach to
        <a>remote playback device</a> devices through any of the above means.
      </p>
    </section>
    <section class='informative'>
      <h2>Use cases and requirements</h2>
      <p>
        The use cases and requirements of this specification are captured in a
        separate document available <a href='https://github.com/w3c/remote-playback/blob/gh-pages/use-cases.md'>here</a>.
      </p>
    </section>
    <section>
      <h2>Dependencies</h2>
      <p>
        The following concepts and interfaces are defined in [[!HTML]]:
      </p>
      <ul>
        <li>
          <dfn><a href=
          'https://html.spec.whatwg.org/multipage/embedded-content.html#htmlmediaelement'>HTMLMediaElement</a></dfn>
        </li>
        <li>
          <dfn><a href='https://html.spec.whatwg.org/multipage/embedded-content.html#media-element'>media element</a></dfn>
        </li>
      </ul>
    </section>
    <section>
      <h2>
        Examples
      </h2>
      <p>
        This section shows the code examples that highlight the usage of the main features of the Remote Playback API.
        In these examples, <code>player.html</code> implements the player page controlling the remote playback and
        <code>media.ext</code> is the media file to be played remotely. Both the page and the media are served from the
        domain <code>https://example.org</code>. Please refer to the comments in the code examples for further details.
      </p>
      <section>
        <h3>
          Monitor availability of remote playback devices example
        </h3>
        <pre class="example highlight">
&lt;!-- player.html --&gt;
&lt;!-- The video element with custom controls that supports remote playback. --&gt;
&lt;video src="https://example.org/media.ext" /&gt;
&lt;button id="remotePlaybackBtn" style="display: none;"&gt;Play remotely&lt;/button&gt;
&lt;script&gt;
  // The "Play remotely" button is visible if at least one remote playback device is available.
  var remotePlaybackBtn = document.querySelector("video");
  // Show or hide the remote playback button depending on device availability.
  var handleAvailabilityChange = function(available) {
    remotePlaybackBtn.style.display = available ? "inline" : "none";
  };
  var videoElem = document.getElementById("videoElement");
  // Promise is fulfilled as soon as the remote playback device availability is known.
  videoElem.remote.getAvailability().then(function(availability) {
    // availability.value may be kept up-to-date by the controlling UA as long
    // as the availability object is alive. It is advised for the web developers
    // to discard the object as soon as it's not needed.
    handleAvailabilityChange(availability.value);
    availability.onchange = function() { handleAvailabilityChange(this.value); };
  }).catch(function() {
    // Availability monitoring is not supported by the platform, so discovery of
    // remote playback devices will happen only after remote.connect() is called.
    // Pretend the devices are available for simplicity; or, one could implement
    // a third state for the button.
    handleAvailabilityChange(true);
  });
&lt;/script&gt;
        </pre>
      </section>
      <section>
        <h3>
          Starting remote playback of a video example
        </h3>
        <pre class="example highlight">
&lt;!-- player.html --&gt;
&lt;script&gt;
  remotePlaybackBtn.onclick = function () {
    // Start remote playback.
    videoElem.remote.connect()
      // Update the UI and monitor the connected state.
      .then(setupRemotePlayback);
      // Otherwise, the user cancelled the selection UI or no screens were found.
  };
&lt;script&gt;
        </pre>
      </section>
      <section>
        <h3>
          Monitoring remote playback state changes
        </h3>
        <pre class="example highlight">
&lt;!-- player.html --&gt;
&lt;script&gt;
  // The remote playback may be initiated by the user agent.
  if (videoElem.remote.state != 'disconnected')
    setupRemotePlayback();
  videoElem.remote.onstatechange = function(evt) {
    if (videoElem.remote.state != 'disconnected')
      setupRemotePlayback();
    else
      stopRemotePlayback();
  };
&lt;script&gt;
        </pre>
      </section>
    </section>
    <section>
      <h2>API</h2>
      <section>
        <h3><code><a>RemotePlayback</a></code> interface</h3>
        <pre class='idl'>
          interface RemotePlayback : EventTarget {
            Promise&lt;RemotePlaybackAvailability&gt; getAvailability();

            readonly attribute RemotePlaybackState state;

            attribute EventHandler onstatechange;

            Promise&lt;bool&gt; connect();
          };

          enum RemotePlaybackState {
            "connecting",
            "connected",
            "disconnected"
          };
        </pre>
        <section>
          <h4>
            Initiate remote playback
          </h4>
          <p>
            When the <code><a for="RemotePlayback">connect</a>()</code>
            method is called, the <a>user agent</a> MUST run the following
            steps to <dfn>initiate remote playback</dfn>:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>remote</var>, the <code><a>RemotePlayback</a></code> object
              associated with the media element.
            </dd>
            <dd>
              <var>mediaSourceList</var>, the list of all media sources attributed to media element.
              It includes sources set via <code>srcObject</code>, <code>src</code> attributes and <code>&lt;source&gt;</code>
              elements at the moment <code><a for="RemotePlayback">connect</a>()</code> was called.
            </dd>
            <dt>
              Output
            </dt>
            <dd>
              A promise.
            </dd>
          </dl>
          <ol>
            <li>
              If the <a>user agent</a> knows a priori that playing any source from <var>mediaSourceList</var>
              remotely is not supported by the user agent or any of <a>remote playback device</a> types supported
              by the user agent, return a promise rejected with a <a>NotSupported</a> error and abort the
              remaining steps.
              <div class="note">
                An example of such scenario could be when the user agent only supports <a>media flinging</a> case
                while the media element's source is not a URL that could be passed over to any <a>remote playback device</a>.
              </div>
            </li>
            <li>
              If the algorithm isn't <a>allowed to show a popup</a>, return a
              promise rejected with an <a>InvalidAccessError</a> exception
              and abort these steps.
            </li>
            <li>
              If there is already an unsettled promise from a previous
              call to <code>connect</code> for the same browsing context, return
              a promise rejected with an <a>OperationError</a> exception and
              abort all remaining steps.
            </li>
            <li>
              Let <var>promise</var> be a new promise.
            </li>
            <li>
              Return <var>promise</var> and continue running these steps
              asynchronously.
            </li>
            <li>
              If the <a>user agent</a> is not <a data-lt="monitor the list of available remote playback devices">
              monitoring the list of available remote playback devices</a>, run the steps to
              <a>monitor the list of available remote playback devices</a> in parallel.
            </li>
            <li>
              Request user permission for the use of a <a>remote playback device</a>
              and selection of one remote playback device.
            </li>
            <li>
              If either of the following is true:
              <ol>
                <li>
                  The <a>list of available remote playback devices</a> is empty
                  and will remain so before the request for user permission is
                  completed.
                </li>
                <li>
                  No member in the <a>list of available remote playback devices</a> is a
                  <a>compatible remote playback device</a> for any source from the <var>mediaSourceList</var>.
                </li>
              </ol>
              Then run the following steps:
              <ol>
                <li>
                  Reject <var>promise</var> with a <a>NotFoundError</a> exception.
                </li>
                <li>
                  Abort all remaining steps.
                </li>
              </ol>
            </li>
            <li>
              If the user <em>denied permission</em> to use a device, fulfill
              <var>promise</var> with <code>false</code>, and abort
              all remaining steps.
            </li>
            <li>
              Otherwise, the user <em>granted permission</em> to use a device;
              let <var>device</var> be that device.
            </li>
            <li>
              Set the <a for="RemotePlayback">state</a> of the <var>remote</var> object to
              <a for="RemotePlabyackState">connecting</a>.
            </li>
            <li>
              Fulfill <var>promise</var> with <code>true</code>.
            </li>
            <li>
              <a>Queue a task</a> to fire a simple event</a> with
              the name <a for="RemotePlayback">statechange</a>,
              that uses the <a>change</a> event interface at <var>remote</var>.
              The event must not bubble, must not be cancelable, and has no
              default action.
            </li>
            <li>
              If any of the following steps fails, abort all remaining steps
              and <a>stop the remote playback</a> for <var>remote</var>.
            </li>
            <li>
              Using an implementation specific mechanism start remote playback of
              the <a>best compatible media source</a> from <var>mediaSourceList</var> on <var>device</var>.
            </li>
          </ol>
          <div class="note">
            The details of implementing the permission request and device
            selection are left to the user agent; for example it may show the
            user a dialog and allow the user to select an available device
            (granting permission), or cancel the selection (denying
            permission).
          </div>
          <div class="note">
            The algorithm to select the <dfn>best compatible media source</dfn> for a selected device
            depends on the user agent and supported <a>remote playback device</a> types. For example,
            in case of <a>media mirroring</a> the user agent can simply follow the <a>HTMLMediaElement</a>'s
            <a>resource selection algorithm</a>. However, if <a>media remoting</a> or <a>media flinging</a> is used,
            the best media source depends on the selected <a>remote playback device</a> fetch and playback capabilities.
          </div>
        </section>
        <section>
          <h4>The <code><a for="RemotePlayback">state</a></code> attribute</h4>
          <p>
            The <dfn><code>state</code></dfn> attribute represents the
            <a>remote playback</a> connection's current state. It can take one of
            the values of <a>RemotePlaybackState</a> depending on the
            connection state:
          </p>
          <ul dfn-for="RemotePlaybackState">
            <li>
              <dfn>connecting</dfn> means that the user agent is attempting to
              <a>initiate remote playback</a> with the selected <a>remote playback device</a>.
              This is the initial state when the <code>promise</code> returned by
              <code><a for="RemotePlayback">connect</a>()</code> is fulfilled with <code>true</code>.
              The local playback of the media element continues in this
              state and media commands still take effect on the local playback.
            </li>
            <li>
              <dfn>connected</dfn> means that the transition from local to
              <a>remote playback</a> has finished and all media commands now
              take effect on the playback state of the <a>remote playback device</a>
            </li>
            <li>
              <dfn>disconnected</dfn> means that the <a>remote playback</a>
              has not been initiated, has failed to initiate or has been
              stopped. All media commands will take effect on the local
              playback in this state. The <a>remote playback</a> can be
              initiated through a call to <code><a for="RemotePlayback">connect</a>()</code>.
            </li>
          </ul>
        </section>
        <section>
          <h4>
            Establishing a connection with a remote playback device
          </h4>
          <p>
            When the <a>user agent</a> is to <dfn>establish a connection with the remote playback device</dfn>,
            it MUST run the following steps:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>remotePlayback</var>, the <code>RemotePlayback</code> object that is to be connected.
              The <a>remote playback state</a> of <var>remotePlayback</var> must be
              <a for="RemotePlaybackState">connecting</a>.
            </dd>
          </dl>
          <ol>
            <li>
              Request connection of <var>remotePlayback</var> to the <a>remote playback device</a>.
            </li>
            <li>
              If connection completes successfully, <a>queue a task</a> to run the following steps:
              <ol>
                <li>
                  Set the <a>remote playback state</a> of <var>remotePlayback</var> to
                  <a for="RemotePlaybackState">connected</a>.
                </li>
                <li>
                  <a>Fire a simple event</a> named <a>statechange</a> at <var>remotePlayback</var>.
                </li>
              </ol>
            </li>
          </ol>
          <div class="note">
            The mechanism that is used to connect the user agent with the <a>remote playback device</a> and
            play the <a>remote playback source</a> is an implementation choice of the user agent. The
            connection will likely have to provide a two-way messaging abstraction capable of carrying media commands to
            the remote playback device and receiving media playback state in order to keep the remoted
            media element state in sync, unless <a>media mirroring</a> is used.
          </div>
          <div class="note">
            If the connection step does not complete successfully, the user
            agent may choose to re-execute the connection algorithm at a later time.
          </div>
        </section>
        <section>
          <h4>Media commands and media playback state</h4>
          <p>
            The HTMLMediaElement interface interacts with the remotely played media
            as soon as the state of RemotePlayback has changed to "connected".
            All the media commands are sent to the remote playback device in order to change
            the state of the remotely played media while all the status updates received from
            the remote playback device are reflected on the HTMLMediaElement's state.
            If sending any command fails, the user agent stops remote
            playback and the state changes to "disconnected".
          </p>
        </section>
        <section>
          <h4>Stopping remote playback</h4>
          <p>
            When the <a>user agent</a> is to <dfn>stop remote playback<dfn>,
            it MUST do the following:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>remotePlayback</var>, the <a>remote playback</a> to be stopped.
            </dd>
          </dl>
          <ol>
            <li>
              If the <a for="RemotePlabyack"><code>state</code></a> of <var>remotePlayback</var> is not
              <code>connected</code>, abort the remaining steps.
            </li>
            <li>
              <a>Queue a task</a> to run the following steps:
              <ol>
                <li>
                  Request stopping the playback of the media from the <a>remote playback device</a>.
                </li>
                <li>
                  Change the <var>remotePlayback</var>'s <code>state</code> to <code>disconnected</code>.
                </li>
                <li>
                  <a>Fire an event</a> with the name <a for="RemotePlayback">statechange</a> at <var>remotePlayback</var>.
                </li>
              </ol>
            </li>
          </ol>
          <div class="note">
            The remote playback device might not stop the remote playback of the media when requested by the user agent
            since it's implementation specific and depends on the device in question. In such case stopping remote playback
            merely means the user agent disconnecting from the remote playback device.
          </div>
        </section>
        <section>
          <h4>
            Event Handlers
          </h4>
          <p>
            The following are the event handlers (and their corresponding event
            handler event types) that must be supported, as event handler IDL
            attributes, by objects implementing the <a>RemotePlayback</a> interface:
          </p>
          <table dfn-for="RemotePlayback">
            <thead>
              <tr>
                <th>
                  Event handler
                </th>
                <th>
                  Event handler event type
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <dfn><code>onstatechange</code></dfn>
                </td>
                <td>
                  <dfn><code>statechange</code></dfn>
                </td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section>
        <h3><code>RemotePlaybackAvailability</code> interface</h3>
        <pre class='idl'>
          interface <dfn>RemotePlaybackAvailability</dfn> : EventTarget {
            readonly attribute boolean value;
            attribute EventHandler onchange;
          };
        </pre>
        <p>
          A <a><code>RemotePlaybackAvailability</code></a> object is associated with available <a>remote playback devices</a>
          and represents the <dfn>remote playback device availability</dfn> for the media element. If the user
          agent can <a>monitor the list of available remote playback devices</a> in the background (without
          a pending request to <code><a for="RemotePlayback">connect()</a></code>), the
          <a><code>RemotePlaybackAvailability</a></code> object MUST be implemented by the user agent. Otherwise, the
          promise returned by <code><a for="RemotePlayback">getAvailability</a>()</code> MUST be rejected with <a>NotSupportedError</a>.
        </p>
        <p>
          The <dfn for="RemotePlaybackAvailability">value</dfn> attribute MUST return the last value it was set to.
          The value is updated by the <a>monitor the list of available remote playback devices</a> algorithm.
        </p>
        <p>
          The <dfn for="RemotePlaybackAvailability">onchange</dfn> attribute is an <a>event handler</a> which
          corresponding <a>event handler event type</a> is <dfn><code>change</code></dfn>.
        </p>
        <section>
          <h4>
            The set of availability objects
          </h4>
          <p>
            The <a>user agent</a> MUST keep track of the <dfn>set of
            availability objects</dfn> requested through the <code><a for=
            "RemotePlayback">getAvailability</a>()</code> method. The
            <a>set of availability objects</a> is represented as a set of
            tuples <em>(<var>availability</var>, <var>availabilitySource</var>)</em>,
            initially empty, where:
          </p>
          <ol>
            <li>
              <var>availability</var> is a live <a>RemotePlaybackAvailability</a> object;
            </li>
            <li>
              <var>availabilitySource</var> is the <a>source</a> of the media element
              when <code><a for="RemotePlayback">getAvailability</a>()</code> is called to
              create <var>availability</var>.
            </li>
          </ol>
        </section>
        <section>
          <h4>
            The list of available remote playback devices
          </h4>
          <p>
            The <a>user agent</a> MUST keep a <dfn>list of available
            remote playback devices</dfn>. This current list of <a>remote playback devices</a>
            may be used for initiating remote playback, and is
            populated based on an implementation specific discovery mechanism.
            It is set to the most recent result of the algorithm to <a>monitor
            the list of available remote playback devices</a>.
          </p>
          <p>
            While there are live <a>RemotePlaybackAvailability</a> objects, the
            <a>user agent</a> MAY <a>monitor the list of available remote playback devices</a> continuously,
            so that pages can use the <a for="RemotePlaybackAvailability">value</a> property of a
            <a>RemotePlaybackAvailability</a> object to offer remote playback only
            when there are available devices. However, the <a>user agent</a>
            may not support continuous availability monitoring; for example,
            because of platform or power consumption restrictions. In this case
            the promise returned by <code><a for="RemotePlayback">getAvailability</a>()</code>
            MUST be rejected with <a>NotSupportedError</a> and the algorithm to <a>monitor
            the list of available remote playback devices</a> will only run as part of the
            <a>initiate remote playback</a> algorithm.
          </p>
          <p>
            When there are no live <a>RemotePlaybackAvailability</a> objects
            (that is, the <a>set of availability objects</a> is empty), user
            agents SHOULD NOT <a>monitor the list of available remote playback devices</a> to satisfy the
            <a>power saving non-functional requirement</a>. To further save power,
            the <a>user agent</a> MAY also keep track of whether the page
            holding a <a>RemotePlaybackAvailability</a> object is in the
            foreground. Using this information, implementation specific
            discovery of <a>remote playback devices</a> can be resumed or
            suspended.
          </p>
          <p>
            Some <a>remote playback devices</a> may only be able to display a
            subset of Web content because of functional, security or hardware
            limitations. Examples are set-top boxes, smart TVs or networked
            speakers capable of rendering only certain formats of video and/or audio.
            We say that such a device is a <dfn>compatible remote playback device</dfn> for a
            <a>media element source</a> if the <a>user agent</a> can
            reasonably guarantee that the remote playback of the media speficied by the source
            on that device will succeed.
          </p>
        </section>
        <section>
          <h4>
            Getting the <a>remote playback devices</a> availability information
          </h4>
          <p>
            When the <code><dfn for="RemotePlayback">getAvailability</dfn>()</code> method is
            called, the user agent MUST run the following steps:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>mediaSourceList</var>, a list of sources attributed to the media element.
            </dd>
            <dt>
              Output
            </dt>
            <dd>
              <var>promise</var>, a promise.
            </dd>
          </dl>
          <ol>
            <li>
              Let <var>promise</var> be a new promise.
            </li>
            <li>
              Return <var>promise</var>, and run the following steps below:
            </li>
            <li>If the user agent is unable to <a>monitor the list of available
            remote playback devices</a> for the entire lifetime of the browsing context
            (for instance, because the user has disabled this feature), then:
              <ol>
                <li>
                  Fulfill <var>promise</var> with a new
                  <code>RemotePlaybackAvailability</code> object with its
                  <code>value</code> property set to <code>false</code>.
                </li>
                <li>Abort all the remaining steps.
                </li>
              </ol>
            </li>
            <li>If the user agent is unable to continuously <a>monitor the list
            of available remote playback devices</a> but can do it for a short period of time
            when initiating remote playback, then:
              <ol>
                <li>
                  Reject <var>promise</var> with a <a>NotSupportedError</a>
                  exception.
                </li>
                <li>Abort all the remaining steps.
                </li>
              </ol>
            </li>
            <li>
              If there exists a tuple <em>(<var>availability</var>,
              <var>availabilitySource</var>)</em> in the <a>set of availability
              objects</a> where <var>availabilitySource<var> is present in <var>mediaSourceList</var>,
              then:
              <ol>
                <li>
                  Fulfill <var>promise</var> with <var>availability</var>.
                </li>
                <li>
                  Abort all the remaining steps.
                </li>
              </ol>
            </li>
            <li>
              Let <var>availability</var> be a new <code>RemotePlaybackAvailability</code>
              object with its <code>value</code> property set to
              <code>false</code> if the <a>list of available remote playback devices</a>
              is empty or none of them is compatible with any source from <var>mediaSourceList</var>,
              <code>true</code> otherwise.
            </li>
            <li>
              For each <var>availabilitySource</var> in <var>mediaSourceList</var>, create a tuple
              <em>(<var>availability</var>, <var>availabilitySource</var>)</em> and add it to the
              <a>set of availability objects</a>.
            </li>
            <li>
              Run the algorithm to <a>monitor the list of available remote playback devices</a>.
            </li>
            <li>
              Fulfill <var>promise</var> with <var>availability</var>.
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Monitoring the list of available remote playback devices
          </h4>
          <p>
            If the <a>set of availability objects</a> is non-empty, or there is
            a pending request to <a for="RemotePlayback" data-lt="connect">initiate remote playback</a>,
            the <a>user agent</a> MUST <dfn>monitor the list of available remote playback devices</dfn> by
            running the following steps:
          </p>
          <ol link-for="RemotePlaybackAvailability">
            <li>
              Retrieve available remote playback devices (using an implementation specific mechanism)
              and let <var>newDevices</var> be this list.
            </li>
            <li>
              For each member <em>(<var>availability</var>, <var>availabilitySource</var>)</em>
              of the <a>set of availability objects</a>:
              <ol>
                <li>
                  Set <var>previousAvailabilityValue</var> to the value of <var>availability</var>'s <a>value</a> property.
                </li>
                <li>
                  Let <var>newAvailabilityValue</var> be <code>true</code> if <var>newDevices</var> is not empty
                  and at least one device in <var>newDevices</var> is a <a>compatible remote playback device</a>
                  for <var>availabilitySource</var>. Otherwise, set <var>newAvailabilityValue</var> to <code>false</code>.
                </li>
                <li>
                  If <var>previousAvailabilityValue</var> is not equal to <var>newAvailabilityValue</var>, then
                  <a>queue a task</a> to run the following steps:
                  <ol>
                    <li>
                      Set <var>availability</var>'s <a>value</a> property to <var>newAvailabilityValue</var>.
                    </li>
                    <li>
                      <a>Fire a simple event</a> named <a>change</a> at <var>availability</var>.
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
              Set the <a>list of available remote playback devices</a> to the value of <var>newDevices</var>.
            </li>
          </ol>
          <p>
            When a <a>RemotePlaybackAvailability</a> object is no longer alive
            (in other words, is eligible for garbage collection), the <a>user agent</a>
            SHOULD run the following steps:
          </p>
          <ol>
            <li>
              Find and remove any entry <em>(<var>availability</var>, <var>availabilitySource</var>)</em> in the
              <a>set of availability objects</a> for the newly deceased <var>availability</var>.
            </li>
            <li>
              If the <a>set of availability objects</a> is now empty and there is no pending request to
              <a for="RemotePlabyack" data-lt="connect">initiate remote playback</a>, cancel any pending task
              to <a>monitor the list of available remote playback devices</a> for power saving purposes.
            </li>
          </ol>
          <div class="note">
            The mechanism used to monitor <a>remote playback devices</a> availability and determine the
            compatibility of a <a>remote playback device</a> with a given media element source is left to the user agent.
          </div>
        </section>
      </section>
    </section>
    <section>
      <h2>Extension to the <code><a>HTMLMediaElement</a></code></h2>
      <pre class='idl'>
        partial interface HTMLMediaElement {
          readonly attribute RemotePlayback remote;

          [CEReactions] attribute boolean disableRemotePlayback;
        };
      </pre>
      <p>
        The <a for='HTMLMediaElement'>remote</a> attribute MUST return the <a>RemotePlayback</a>
        instance associated with the <a>media element</a>.
      </p>
      <p>
        The <a for='HTMLMediaElement'>disableRemotePlayback</a> IDL attribute
        MUST reflect the content attribute of the same name.
      </p>

      <section>
        <h2>Disabling remote playback</h2>
        <p>
          If the <code>disableRemotePlayback</code> attribute is present on the
          <a>media element</a>, the <a>user agent</a> MUST NOT play the media
          remotely or present any UI to do so.
        </p>
      </section>
    </section>
  </body>
</html>
